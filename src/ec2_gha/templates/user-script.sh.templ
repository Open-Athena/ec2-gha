#!/bin/bash
set -e
# Helper functions
log() { echo "[$$(date '+%Y-%m-%d %H:%M:%S')] $$1" | tee -a /var/log/runner-setup.log; }
log_error() { log "ERROR: $$1" >&2; }

# Function to flush CloudWatch logs before shutdown
flush_cloudwatch_logs() {
    log "Stopping CloudWatch agent to flush logs"
    if systemctl is-active --quiet amazon-cloudwatch-agent; then
        systemctl stop amazon-cloudwatch-agent 2>/dev/null || \
            /opt/aws/amazon-cloudwatch-agent/bin/amazon-cloudwatch-agent-ctl \
                -a stop -m ec2 2>/dev/null || true
    fi
}

# Create common functions file
cat > /usr/local/bin/runner-common-functions.sh << 'EOCF'
#!/bin/bash
log() { echo "[$$(date '+%Y-%m-%d %H:%M:%S')] $$1" | tee -a /var/log/runner-setup.log; }
flush_cloudwatch_logs() {
    log "Stopping CloudWatch agent to flush logs"
    if systemctl is-active --quiet amazon-cloudwatch-agent; then
        systemctl stop amazon-cloudwatch-agent 2>/dev/null || \
            /opt/aws/amazon-cloudwatch-agent/bin/amazon-cloudwatch-agent-ctl \
                -a stop -m ec2 2>/dev/null || true
    fi
}
EOCF

# Get metadata (IMDSv2 compatible)
get_metadata() {
    local path="$$1"
    local token=$$(curl -X PUT -H "X-aws-ec2-metadata-token-ttl-seconds: 300" http://169.254.169.254/latest/api/token 2>/dev/null || true)
    if [ -n "$$token" ]; then
        curl -s -H "X-aws-ec2-metadata-token: $$token" "http://169.254.169.254/latest/meta-data/$$path" 2>/dev/null || echo "unknown"
    else
        curl -s "http://169.254.169.254/latest/meta-data/$$path" 2>/dev/null || echo "unknown"
    fi
}

logger "EC2-GHA: Starting userdata script"
trap 'logger "EC2-GHA: Script failed at line $$LINENO with exit code $$?"' ERR

INSTANCE_ID=$$(get_metadata "instance-id")

terminate_instance() {
    local reason="$$1"
    log "FATAL: $$reason"
    log "Terminating instance $$INSTANCE_ID due to setup failure"

    # Try to remove runner if it was partially configured
    if [ -f "$$homedir/config.sh" ] && [ -n "$${RUNNER_TOKEN:-}" ]; then
        cd "$$homedir" && ./config.sh remove --token "$${RUNNER_TOKEN}" || true
    fi

    flush_cloudwatch_logs
    shutdown -h now
    exit 1
}

# Trap errors and ensure termination on failure
trap 'terminate_instance "Setup script failed with error on line $$LINENO"' ERR

# Set up registration timeout failsafe
REGISTRATION_TIMEOUT="$runner_registration_timeout"
# Validate timeout is a number, default to 300 if not
if ! [[ "$$REGISTRATION_TIMEOUT" =~ ^[0-9]+$$ ]]; then
    logger "EC2-GHA: Invalid timeout '$$REGISTRATION_TIMEOUT', using default 300"
    REGISTRATION_TIMEOUT=300
fi
logger "EC2-GHA: Registration timeout set to $$REGISTRATION_TIMEOUT seconds"
(
    log "Watchdog: Starting $$REGISTRATION_TIMEOUT second timeout"
    sleep $$REGISTRATION_TIMEOUT
    if [ ! -f /var/run/github-runner-registered ]; then
        log "Watchdog: Registration marker not found after timeout"
        terminate_instance "Runner failed to register within $$REGISTRATION_TIMEOUT seconds"
    else
        log "Watchdog: Registration marker found, exiting normally"
    fi
) &
REGISTRATION_WATCHDOG_PID=$$!
log "Watchdog PID: $$REGISTRATION_WATCHDOG_PID"
# Save watchdog PID to file so it survives exec redirect
echo $$REGISTRATION_WATCHDOG_PID > /var/run/github-runner-watchdog.pid

$userdata

# Initialize homedir from template variable
homedir="$homedir"

# Determine home directory if not specified or set to AUTO
if [ -z "$$homedir" ] || [ "$$homedir" = "AUTO" ]; then
    # Try to find the default non-root user's home directory
    # Check for common cloud-init created users
    for user in ubuntu ec2-user centos admin debian fedora alpine arch; do
        if id "$$user" &>/dev/null; then
            homedir="/home/$$user"
            log "Auto-detected: $$homedir"
            break
        fi
    done

    # Fallback if no standard user found
    if [ -z "$$homedir" ] || [ "$$homedir" = "AUTO" ]; then
        # Get the first non-root user's home directory that actually exists
        homedir=$$(getent passwd | awk -F: '$$3 >= 1000 && $$3 < 65534 && $$6 ~ /^\/home\// {print $$6}' | while read dir; do
            if [ -d "$$dir" ]; then
                echo "$$dir"
                break
            fi
        done)

        if [ -z "$$homedir" ]; then
            homedir="/home/ec2-user"  # Ultimate fallback
            log "Using fallback: $$homedir"
        else
            # Use stat to get the actual owner of the directory
            owner=$$(stat -c "%U" "$$homedir" 2>/dev/null || stat -f "%Su" "$$homedir" 2>/dev/null)
            log "Detected: $$homedir ($$owner)"
        fi
    fi
else
    log "Using: $$homedir"
fi

# Fetch instance metadata before redirecting output
INSTANCE_TYPE=$$(get_metadata "instance-type")
INSTANCE_ID=$$(get_metadata "instance-id")
REGION=$$(get_metadata "placement/region")
AZ=$$(get_metadata "placement/availability-zone")

# Redirect runner setup logs to a file for CloudWatch
exec >> /var/log/runner-setup.log 2>&1
log "Starting runner setup"

log "Instance metadata: Type=$${INSTANCE_TYPE} ID=$${INSTANCE_ID} Region=$${REGION} AZ=$${AZ}"

# Set up maximum lifetime timeout - do this early to ensure cleanup
MAX_LIFETIME_MINUTES=$max_instance_lifetime
log "Setting up maximum lifetime timeout: $${MAX_LIFETIME_MINUTES} minutes"
nohup bash -c "sleep $${MAX_LIFETIME_MINUTES}m && echo '[$$(date)] Maximum lifetime reached' && shutdown -h now" > /var/log/max-lifetime.log 2>&1 &

# Configure CloudWatch Logs if enabled
if [ "$cloudwatch_logs_group" != "" ]; then
    log "Installing CloudWatch agent"
    # Use a subshell to prevent CloudWatch failures from stopping the entire script
    (

    # Wait for dpkg lock to be released (up to 2 minutes)
    log "Waiting for dpkg lock to be released..."
    timeout=120
    while fuser /var/lib/dpkg/lock-frontend >/dev/null 2>&1 || fuser /var/lib/dpkg/lock >/dev/null 2>&1; do
        if [ $$timeout -le 0 ]; then
            log "WARNING: dpkg lock timeout, proceeding anyway"
            break
        fi
        log "dpkg is locked, waiting... ($$timeout seconds remaining)"
        sleep 5
        timeout=$$((timeout - 5))
    done

    # Download and install CloudWatch agent
    wget -q https://s3.amazonaws.com/amazoncloudwatch-agent/ubuntu/amd64/latest/amazon-cloudwatch-agent.deb
    dpkg -i -E ./amazon-cloudwatch-agent.deb
    rm amazon-cloudwatch-agent.deb

    # Configure CloudWatch agent
    cat > /opt/aws/amazon-cloudwatch-agent/etc/amazon-cloudwatch-agent.json << 'EOF'
{
  "agent": {
    "run_as_user": "cwagent"
  },
  "logs": {
    "logs_collected": {
      "files": {
        "collect_list": [
          {
            "file_path": "/var/log/runner-setup.log",
            "log_group_name": "$cloudwatch_logs_group",
            "log_stream_name": "{instance_id}/runner-setup",
            "timezone": "UTC"
          },
          {
            "file_path": "/tmp/job-started-hook.log",
            "log_group_name": "$cloudwatch_logs_group",
            "log_stream_name": "{instance_id}/job-started",
            "timezone": "UTC"
          },
          {
            "file_path": "/tmp/job-completed-hook.log",
            "log_group_name": "$cloudwatch_logs_group",
            "log_stream_name": "{instance_id}/job-completed",
            "timezone": "UTC"
          },
          {
            "file_path": "/tmp/termination-check.log",
            "log_group_name": "$cloudwatch_logs_group",
            "log_stream_name": "{instance_id}/termination",
            "timezone": "UTC"
          },
          {
            "file_path": "$$homedir/_diag/Runner_**.log",
            "log_group_name": "$cloudwatch_logs_group",
            "log_stream_name": "{instance_id}/runner-diag",
            "timezone": "UTC"
          },
          {
            "file_path": "$$homedir/_diag/Worker_**.log",
            "log_group_name": "$cloudwatch_logs_group",
            "log_stream_name": "{instance_id}/worker-diag",
            "timezone": "UTC"
          }
        ]
      }
    }
  }
}
EOF

    # Start CloudWatch agent
    /opt/aws/amazon-cloudwatch-agent/bin/amazon-cloudwatch-agent-ctl \
        -a fetch-config \
        -m ec2 \
        -c file:/opt/aws/amazon-cloudwatch-agent/etc/amazon-cloudwatch-agent.json \
        -s

    log "CloudWatch agent started"
    ) || log "WARNING: CloudWatch agent installation failed, continuing without it"
fi

# Configure SSH access if public key provided
if [ -n "$ssh_pubkey" ]; then
    log "Configuring SSH access"

    # Determine the default user based on the home directory owner
    DEFAULT_USER=$$(stat -c "%U" "$$homedir" 2>/dev/null || echo "root")

    # Create .ssh directory if it doesn't exist
    mkdir -p "$homedir/.ssh"
    chmod 700 "$homedir/.ssh"

    # Add the public key to authorized_keys
    echo "$ssh_pubkey" >> "$$homedir/.ssh/authorized_keys"
    chmod 600 "$$homedir/.ssh/authorized_keys"

    # Set proper ownership
    if [ "$$DEFAULT_USER" != "root" ]; then
        chown -R "$$DEFAULT_USER:$$DEFAULT_USER" "$$homedir/.ssh"
    fi

    log "SSH key added for user $$DEFAULT_USER"
fi

log "Working directory: $$homedir"
cd "$$homedir"

echo "$script" > pre-runner-script.sh
log "Running pre-runner script"
source pre-runner-script.sh
export RUNNER_ALLOW_RUNASROOT=1
# Detect architecture and download appropriate runner
ARCH=$$(uname -m)
if [ "$$ARCH" = "aarch64" ] || [ "$$ARCH" = "arm64" ]; then
    # For ARM, replace x64 with arm64 in the URL
    RUNNER_URL=$$(echo "$runner_release" | sed 's/x64/arm64/g')
    log "ARM detected, using: $$RUNNER_URL"
else
    RUNNER_URL="$runner_release"
    log "x64 detected, using: $$RUNNER_URL"
fi
curl -L $$RUNNER_URL -o runner.tar.gz
log "Extracting runner"
# `--no-overwrite-dir` is important, otherwise `$$homedir` ends up `chown`'d to `1001:docker`, and `sshd` will refuse connection attempts to `$$homedir`
tar --no-overwrite-dir -xzf runner.tar.gz
# Create job tracking scripts
cat > /usr/local/bin/job-started-hook.sh << 'EOFS'
#!/bin/bash
exec >> /tmp/job-started-hook.log 2>&1
echo "[$$(date)] ${log_prefix_job_started} $${GITHUB_JOB}"
mkdir -p /var/run/github-runner-jobs
echo '{"status":"running"}' > /var/run/github-runner-jobs/$${GITHUB_RUN_ID}-$${GITHUB_JOB}.job
touch /var/run/github-runner-last-activity
# Mark that at least one job has run
touch /var/run/github-runner-has-run-job
EOFS

cat > /usr/local/bin/job-completed-hook.sh << 'EOFC'
#!/bin/bash
exec >> /tmp/job-completed-hook.log 2>&1
echo "[$$(date)] ${log_prefix_job_completed} $${GITHUB_JOB}"
rm -f /var/run/github-runner-jobs/$${GITHUB_RUN_ID}-$${GITHUB_JOB}.job
touch /var/run/github-runner-last-activity
EOFC

cat > /usr/local/bin/check-runner-termination.sh << 'EOFT'
#!/bin/bash
exec >> /tmp/termination-check.log 2>&1

source /usr/local/bin/runner-common-functions.sh
A="/var/run/github-runner-last-activity"
J="/var/run/github-runner-jobs"
H="/var/run/github-runner-has-run-job"
[ ! -f "$$A" ] && touch "$$A"
L=$$(stat -c %Y "$$A" 2>/dev/null || echo 0)
I=$$(($$(date +%s)-L))
# Use initial grace period only if no job has ever run
if [ -f "$$H" ]; then G=$${RUNNER_GRACE_PERIOD:-60}; else G=$${RUNNER_INITIAL_GRACE_PERIOD:-180}; fi
R=$$(grep -l '"status":"running"' $$J/*.job 2>/dev/null | wc -l || echo 0)
if [ $$R -eq 0 ] && [ $$I -gt $$G ]; then
    echo "[$$(date)] Terminating: idle $$I > grace $$G, proceeding with termination"
    [ -f "$$homedir/config.sh" ] && cd "$$homedir" && pkill -INT -f "Runner.Listener" 2>/dev/null || true
    sleep 2
    if [ -f "$$homedir/config.sh" ] && RUNNER_ALLOW_RUNASROOT=1 ./config.sh remove --token $token; then
        echo "[$$(date)] Runner removed from GitHub successfully"
    fi

    flush_cloudwatch_logs
    sudo shutdown -h now "Runner terminating after idle timeout"
else
    if [ $$R -gt 0 ]; then
        echo "[$$(date)] $$R job(s) still running, not terminating"
    else
        echo "[$$(date)] No jobs running, idle $$I seconds (grace period: $$G seconds)"
    fi
fi
EOFT

chmod +x /usr/local/bin/runner-common-functions.sh /usr/local/bin/job-started-hook.sh /usr/local/bin/job-completed-hook.sh /usr/local/bin/check-runner-termination.sh

# Set up runner hooks
echo "ACTIONS_RUNNER_HOOK_JOB_STARTED=/usr/local/bin/job-started-hook.sh" > .env
echo "ACTIONS_RUNNER_HOOK_JOB_COMPLETED=/usr/local/bin/job-completed-hook.sh" >> .env
echo "RUNNER_HOME=$$homedir" >> .env
echo "RUNNER_GRACE_PERIOD=$runner_grace_period" >> .env
echo "RUNNER_INITIAL_GRACE_PERIOD=$runner_initial_grace_period" >> .env
echo "RUNNER_POLL_INTERVAL=$runner_poll_interval" >> .env

# Set up job tracking directory
mkdir -p /var/run/github-runner-jobs

# Create initial activity timestamp
touch /var/run/github-runner-last-activity

# Set up periodic termination check using systemd
cat > /etc/systemd/system/runner-termination-check.service << 'EOF'
[Unit]
Description=Check GitHub runner termination conditions
After=network.target

[Service]
Type=oneshot
ExecStart=/usr/local/bin/check-runner-termination.sh
EOF

cat > /etc/systemd/system/runner-termination-check.timer << EOF
[Unit]
Description=Periodic GitHub runner termination check
Requires=runner-termination-check.service

[Timer]
OnBootSec=60s
OnUnitActiveSec=${runner_poll_interval}s

[Install]
WantedBy=timers.target
EOF

# Enable and start the timer
systemctl daemon-reload
systemctl enable runner-termination-check.timer
systemctl start runner-termination-check.timer

# Get instance metadata for descriptive runner name
INSTANCE_ID=$$(get_metadata "instance-id")
INSTANCE_TYPE=$$(get_metadata "instance-type")

# Create runner name with just the instance ID for uniqueness
RUNNER_NAME="ec2-$${INSTANCE_ID}"

# Build additional labels with metadata for easier correlation
# These will be visible in the GitHub runner management UI
METADATA_LABELS=""
METADATA_LABELS="$${METADATA_LABELS},instance-id:$${INSTANCE_ID}"
METADATA_LABELS="$${METADATA_LABELS},instance-type:$${INSTANCE_TYPE}"

# Add GitHub workflow metadata passed from the action
if [ -n "$github_workflow" ]; then
    # Replace spaces and special chars in workflow name for label compatibility
    WORKFLOW_LABEL=$$(echo "$github_workflow" | tr ' /' '-' | tr -cd '[:alnum:]-_')
    METADATA_LABELS="$${METADATA_LABELS},workflow:$${WORKFLOW_LABEL}"
fi
if [ -n "$github_run_id" ]; then
    METADATA_LABELS="$${METADATA_LABELS},run-id:$github_run_id"
fi
if [ -n "$github_run_number" ]; then
    METADATA_LABELS="$${METADATA_LABELS},run-number:$github_run_number"
fi

# Combine provided labels (user + runner-xxx) with instance metadata labels
# The $labels variable already contains user labels and the critical runner-xxx label from Python
ALL_LABELS="$labels$${METADATA_LABELS}"

log "Configuring runner for repo: $repo"
log "Runner name: $${RUNNER_NAME}"
log "Labels: $${ALL_LABELS}"
# Export token for error handler
export RUNNER_TOKEN="$token"

# Attempt to register. If a runner with the same name exists, config.sh will fail
# We use --unattended to prevent interactive prompts
if ! ./config.sh --url https://github.com/$repo --token $token --labels "$${ALL_LABELS}" --name "$${RUNNER_NAME}" --disableupdate --unattended; then
    log_error "Failed to register runner '$${RUNNER_NAME}'"
    log_error "This usually means a runner with this name already exists"
    log_error "If instance ID is 'unknown', metadata fetching likely failed"
    terminate_instance "Runner registration failed"
fi
log "Runner registered successfully"

# Mark registration as complete and kill the watchdog
log "Creating registration marker"
touch /var/run/github-runner-registered
ls -la /var/run/github-runner-registered
# Read watchdog PID from file (survives exec redirect)
if [ -f /var/run/github-runner-watchdog.pid ]; then
    WATCHDOG_PID=$$(cat /var/run/github-runner-watchdog.pid)
    if kill -0 $$WATCHDOG_PID 2>/dev/null; then
        kill $$WATCHDOG_PID 2>/dev/null || true
        log "Killed registration watchdog (PID: $$WATCHDOG_PID)"
    else
        log "Watchdog process $$WATCHDOG_PID already terminated"
    fi
    rm -f /var/run/github-runner-watchdog.pid
fi

log "Starting runner"
# Create marker file for cleanup service
touch /var/run/github-runner-started
# Ensure CloudWatch agent can read diagnostic logs
# The cwagent user needs to traverse into $homedir to reach _diag
# Make $homedir world-executable (but not readable) so cwagent can traverse it
chmod o+x $$homedir
log "Made $$homedir traversable for CloudWatch agent"
# Create _diag directory if it doesn't exist
mkdir -p $$homedir/_diag
# The _diag files are already world-readable by default, just ensure the directory is too
chmod 755 $$homedir/_diag
./run.sh
