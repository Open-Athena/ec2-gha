#!/bin/bash
set -e

# Enable debug tracing to a file for troubleshooting
exec 2> >(tee -a /var/log/runner-debug.log >&2)

# Conditionally enable debug mode
if [ "$debug" = "true" ] || [ "$debug" = "True" ] || [ "$debug" = "1" ]; then
  echo "[DEBUG] Debug mode enabled - set -x active" >&2
  set -x
fi

log() { echo "[$$(date '+%Y-%m-%d %H:%M:%S')] $$1" | tee -a /var/log/runner-setup.log; }
log_error() { log "ERROR: $$1" >&2; }

# Function to flush CloudWatch logs before shutdown
flush_cloudwatch_logs() {
  log "Stopping CloudWatch agent to flush logs"
  if systemctl is-active --quiet amazon-cloudwatch-agent; then
    systemctl stop amazon-cloudwatch-agent 2>/dev/null \
    || /opt/aws/amazon-cloudwatch-agent/bin/amazon-cloudwatch-agent-ctl -a stop -m ec2 2>/dev/null \
    || true
  fi
}

# Create common functions file
cat > /usr/local/bin/runner-common-functions.sh << 'EOCF'
#!/bin/bash
log() { echo "[$$(date '+%Y-%m-%d %H:%M:%S')] $$1" | tee -a /var/log/runner-setup.log; }
flush_cloudwatch_logs() {
  log "Stopping CloudWatch agent to flush logs"
  if systemctl is-active --quiet amazon-cloudwatch-agent; then
    systemctl stop amazon-cloudwatch-agent 2>/dev/null \
    || /opt/aws/amazon-cloudwatch-agent/bin/amazon-cloudwatch-agent-ctl -a stop -m ec2 2>/dev/null \
    || true
  fi
}
EOCF

# Get metadata (IMDSv2 compatible)
get_metadata() {
  local path="$$1"
  local token=$$(curl -X PUT -H "X-aws-ec2-metadata-token-ttl-seconds: 300" http://169.254.169.254/latest/api/token 2>/dev/null || true)
  if [ -n "$$token" ]; then
    curl -s -H "X-aws-ec2-metadata-token: $$token" "http://169.254.169.254/latest/meta-data/$$path" 2>/dev/null || echo "unknown"
  else
    curl -s "http://169.254.169.254/latest/meta-data/$$path" 2>/dev/null || echo "unknown"
  fi
  return 0  # Always return success to avoid set -e issues
}

logger "EC2-GHA: Starting userdata script"
trap 'logger "EC2-GHA: Script failed at line $$LINENO with exit code $$?"' ERR

terminate_instance() {
  local reason="$$1"
  local instance_id=$$(get_metadata "instance-id")

  # Log error prominently
  echo "========================================" | tee -a /var/log/runner-setup.log
  log "FATAL ERROR DETECTED"
  log "Reason: $$reason"
  log "Instance: $$instance_id"
  log "Script location: $$(pwd)"
  log "User: $$(whoami)"
  log "Debug trace available in: /var/log/runner-debug.log"
  echo "========================================" | tee -a /var/log/runner-setup.log

  # Try to remove runner if it was partially configured
  if [ -f "$$homedir/config.sh" ] && [ -n "$${RUNNER_TOKEN:-}" ]; then
    cd "$$homedir" && ./config.sh remove --token "$${RUNNER_TOKEN}" || true
  fi

  flush_cloudwatch_logs

  # Give time for debugging
  log "Sleeping for 300 seconds before shutdown to allow debugging..."
  log "SSH into instance with: ssh ubuntu@$$(curl -s http://169.254.169.254/latest/meta-data/public-ipv4)"
  log "Then check: /var/log/runner-setup.log and /var/log/runner-debug.log"
  sleep 300

  log "Shutting down after debug delay"
  shutdown -h now
  exit 1
}

# Trap errors and ensure termination on failure
trap 'terminate_instance "Setup script failed with error on line $$LINENO"' ERR

# Set up registration timeout failsafe
REGISTRATION_TIMEOUT="$runner_registration_timeout"
# Validate timeout is a number, default to 300 if not
if ! [[ "$$REGISTRATION_TIMEOUT" =~ ^[0-9]+$$ ]]; then
  logger "EC2-GHA: Invalid timeout '$$REGISTRATION_TIMEOUT', using default 300"
  REGISTRATION_TIMEOUT=300
fi
logger "EC2-GHA: Registration timeout set to $$REGISTRATION_TIMEOUT seconds"
(
  log "Watchdog: Starting $$REGISTRATION_TIMEOUT second timeout"
  sleep $$REGISTRATION_TIMEOUT
  if [ ! -f /var/run/github-runner-registered ]; then
    log "Watchdog: Registration marker not found after timeout"
    terminate_instance "Runner failed to register within $$REGISTRATION_TIMEOUT seconds"
  else
    log "Watchdog: Registration marker found, exiting normally"
  fi
) &
REGISTRATION_WATCHDOG_PID=$$!
log "Watchdog PID: $$REGISTRATION_WATCHDOG_PID"
# Save watchdog PID to file so it survives exec redirect
echo $$REGISTRATION_WATCHDOG_PID > /var/run/github-runner-watchdog.pid

$userdata

# Initialize homedir from template variable
homedir="$homedir"

# Determine home directory if not specified or set to AUTO
if [ -z "$$homedir" ] || [ "$$homedir" = "AUTO" ]; then
  # Try to find the default non-root user's home directory
  # Check for common cloud-init created users
  for user in ubuntu ec2-user centos admin debian fedora alpine arch; do
    if id "$$user" &>/dev/null; then
      homedir="/home/$$user"
      log "Auto-detected: $$homedir"
      break
    fi
  done

  # Fallback if no standard user found
  if [ -z "$$homedir" ] || [ "$$homedir" = "AUTO" ]; then
    # Get the first non-root user's home directory that actually exists
    homedir=$$(getent passwd | awk -F: '$$3 >= 1000 && $$3 < 65534 && $$6 ~ /^\/home\// {print $$6}' | while read dir; do
      if [ -d "$$dir" ]; then
        echo "$$dir"
        break
      fi
    done)

    if [ -z "$$homedir" ]; then
      homedir="/home/ec2-user"  # Ultimate fallback
      log "Using fallback: $$homedir"
    else
      # Use stat to get the actual owner of the directory
      owner=$$(stat -c "%U" "$$homedir" 2>/dev/null || stat -f "%Su" "$$homedir" 2>/dev/null)
      log "Detected: $$homedir ($$owner)"
    fi
  fi
else
  log "Using: $$homedir"
fi

# Redirect runner setup logs to a file for CloudWatch
exec >> /var/log/runner-setup.log 2>&1
log "Starting runner setup"

# Fetch instance metadata
INSTANCE_TYPE=$$(get_metadata "instance-type")
INSTANCE_ID=$$(get_metadata "instance-id")
REGION=$$(get_metadata "placement/region")
AZ=$$(get_metadata "placement/availability-zone")

log "Instance metadata: Type=$${INSTANCE_TYPE} ID=$${INSTANCE_ID} Region=$${REGION} AZ=$${AZ}"

# Set up maximum lifetime timeout - do this early to ensure cleanup
MAX_LIFETIME_MINUTES=$max_instance_lifetime
log "Setting up maximum lifetime timeout: $${MAX_LIFETIME_MINUTES} minutes"
nohup bash -c "sleep $${MAX_LIFETIME_MINUTES}m && echo '[$$(date)] Maximum lifetime reached' && shutdown -h now" > /var/log/max-lifetime.log 2>&1 &

# Configure CloudWatch Logs if enabled
if [ "$cloudwatch_logs_group" != "" ]; then
  log "Installing CloudWatch agent"
  # Use a subshell to prevent CloudWatch failures from stopping the entire script
  (

    # Wait for dpkg lock to be released (up to 2 minutes)
    log "Waiting for dpkg lock to be released..."
    timeout=120
    while fuser /var/lib/dpkg/lock-frontend >/dev/null 2>&1 || fuser /var/lib/dpkg/lock >/dev/null 2>&1; do
      if [ $$timeout -le 0 ]; then
        log "WARNING: dpkg lock timeout, proceeding anyway"
        break
      fi
      log "dpkg is locked, waiting... ($$timeout seconds remaining)"
      sleep 5
      timeout=$$((timeout - 5))
    done

    # Download and install CloudWatch agent
    wget -q https://s3.amazonaws.com/amazoncloudwatch-agent/ubuntu/amd64/latest/amazon-cloudwatch-agent.deb
    dpkg -i -E ./amazon-cloudwatch-agent.deb
    rm amazon-cloudwatch-agent.deb

    # Configure CloudWatch agent
    cat > /opt/aws/amazon-cloudwatch-agent/etc/amazon-cloudwatch-agent.json << EOF
{
  "agent": {
    "run_as_user": "cwagent"
  },
  "logs": {
    "logs_collected": {
      "files": {
        "collect_list": [
          { "file_path": "/var/log/runner-setup.log", "log_group_name": "$cloudwatch_logs_group", "log_stream_name": "{instance_id}/runner-setup", "timezone": "UTC" },
          { "file_path": "/var/log/runner-debug.log", "log_group_name": "$cloudwatch_logs_group", "log_stream_name": "{instance_id}/runner-debug", "timezone": "UTC" },
          { "file_path": "/tmp/job-started-hook.log", "log_group_name": "$cloudwatch_logs_group", "log_stream_name": "{instance_id}/job-started", "timezone": "UTC" },
          { "file_path": "/tmp/job-completed-hook.log", "log_group_name": "$cloudwatch_logs_group", "log_stream_name": "{instance_id}/job-completed", "timezone": "UTC" },
          { "file_path": "/tmp/termination-check.log", "log_group_name": "$cloudwatch_logs_group", "log_stream_name": "{instance_id}/termination", "timezone": "UTC" },
          { "file_path": "$homedir/_diag/Runner_**.log", "log_group_name": "$cloudwatch_logs_group", "log_stream_name": "{instance_id}/runner-diag", "timezone": "UTC" },
          { "file_path": "$homedir/_diag/Worker_**.log", "log_group_name": "$cloudwatch_logs_group", "log_stream_name": "{instance_id}/worker-diag", "timezone": "UTC" }
        ]
      }
    }
  }
}
EOF

    # Start CloudWatch agent
    /opt/aws/amazon-cloudwatch-agent/bin/amazon-cloudwatch-agent-ctl \
      -a fetch-config \
      -m ec2 \
      -c file:/opt/aws/amazon-cloudwatch-agent/etc/amazon-cloudwatch-agent.json \
      -s

    log "CloudWatch agent started"
  ) || log "WARNING: CloudWatch agent installation failed, continuing without it"
fi

# Configure SSH access if public key provided
if [ -n "$ssh_pubkey" ]; then
  log "Configuring SSH access"

  # Determine the default user based on the home directory owner
  DEFAULT_USER=$$(stat -c "%U" "$$homedir" 2>/dev/null || echo "root")

  # Create .ssh directory if it doesn't exist
  mkdir -p "$homedir/.ssh"
  chmod 700 "$homedir/.ssh"

  # Add the public key to authorized_keys
  echo "$ssh_pubkey" >> "$$homedir/.ssh/authorized_keys"
  chmod 600 "$$homedir/.ssh/authorized_keys"

  # Set proper ownership
  if [ "$$DEFAULT_USER" != "root" ]; then
    chown -R "$$DEFAULT_USER:$$DEFAULT_USER" "$$homedir/.ssh"
  fi

  log "SSH key added for user $$DEFAULT_USER"
fi

log "Working directory: $$homedir"
cd "$$homedir"

echo "$script" > pre-runner-script.sh
log "Running pre-runner script"
source pre-runner-script.sh
export RUNNER_ALLOW_RUNASROOT=1

# Runner configurations are always provided as JSON from Python
RUNNERS_PER_INSTANCE=$runners_per_instance

# Download runner binary once
ARCH=$$(uname -m)
if [ "$$ARCH" = "aarch64" ] || [ "$$ARCH" = "arm64" ]; then
  RUNNER_URL=$$(echo "$runner_release" | sed 's/x64/arm64/g')
  log "ARM detected, using: $$RUNNER_URL"
else
  RUNNER_URL="$runner_release"
  log "x64 detected, using: $$RUNNER_URL"
fi
curl -L $$RUNNER_URL -o /tmp/runner.tar.gz
log "Downloaded runner binary"
# Create shared job tracking scripts (used by all runners)
cat > /usr/local/bin/job-started-hook.sh << 'EOFS'
#!/bin/bash
exec >> /tmp/job-started-hook.log 2>&1
V="/var/run/github-runner"
RUNNER_IDX="$${RUNNER_INDEX:-0}"
echo "[$$(date)] Runner-$$RUNNER_IDX: ${log_prefix_job_started} $${GITHUB_JOB}"
mkdir -p $$V-jobs
echo '{"status":"running","runner":"'$$RUNNER_IDX'"}' > $$V-jobs/$${GITHUB_RUN_ID}-$${GITHUB_JOB}-$$RUNNER_IDX.job
touch $$V-last-activity $$V-has-run-job
EOFS

cat > /usr/local/bin/job-completed-hook.sh << 'EOFC'
#!/bin/bash
exec >> /tmp/job-completed-hook.log 2>&1
V="/var/run/github-runner"
RUNNER_IDX="$${RUNNER_INDEX:-0}"
echo "[$$(date)] Runner-$$RUNNER_IDX: ${log_prefix_job_completed} $${GITHUB_JOB}"
rm -f $$V-jobs/$${GITHUB_RUN_ID}-$${GITHUB_JOB}-$$RUNNER_IDX.job
touch $$V-last-activity
EOFC

cat > /usr/local/bin/check-runner-termination.sh << EOFT
#!/bin/bash
exec >> /tmp/termination-check.log 2>&1
source /usr/local/bin/runner-common-functions.sh
V="/var/run/github-runner"
A="\$$V-last-activity"
J="\$$V-jobs"
H="\$$V-has-run-job"

[ ! -f "\$$A" ] && touch "\$$A"
L=\$$(stat -c %Y "\$$A" 2>/dev/null || echo 0)
N=\$$(date +%s)
I=\$$((N-L))
[ -f "\$$H" ] && G=\$${RUNNER_GRACE_PERIOD:-60} || G=\$${RUNNER_INITIAL_GRACE_PERIOD:-180}
R=\$$(grep -l '"status":"running"' \$$J/*.job 2>/dev/null | wc -l || echo 0)

if [ \$$R -eq 0 ] && [ \$$I -gt \$$G ]; then
  log "TERMINATING: idle \$$I > grace \$$G"
  # Deregister all runners
  for RUNNER_DIR in $$homedir/runner-*; do
    if [ -d "\$$RUNNER_DIR" ] && [ -f "\$$RUNNER_DIR/config.sh" ]; then
      log "Deregistering runner in \$$RUNNER_DIR"
      cd "\$$RUNNER_DIR"
      pkill -INT -f "\$$RUNNER_DIR/run.sh" 2>/dev/null || true
      sleep 1
      # Read token from stored file
      if [ -f "\$$RUNNER_DIR/.runner-token" ]; then
        TOKEN=\$$(cat "\$$RUNNER_DIR/.runner-token")
        RUNNER_ALLOW_RUNASROOT=1 ./config.sh remove --token \$$TOKEN 2>&1
        log "Deregistration exit: \$$?"
      fi
    fi
  done
  flush_cloudwatch_logs
  log "Shutting down"
  sudo shutdown -h now
else
  [ \$$R -gt 0 ] && log "\$$R job(s) running" || log "Idle \$$I/\$$G sec"
fi
EOFT

chmod +x /usr/local/bin/runner-common-functions.sh /usr/local/bin/job-started-hook.sh /usr/local/bin/job-completed-hook.sh /usr/local/bin/check-runner-termination.sh

# Set up job tracking directory
V="/var/run/github-runner"
mkdir -p $$V-jobs
touch $$V-last-activity

# Set up periodic termination check using systemd
cat > /etc/systemd/system/runner-termination-check.service << EOF
[Unit]
Description=Check GitHub runner termination conditions
After=network.target
[Service]
Type=oneshot
Environment="RUNNER_GRACE_PERIOD=$runner_grace_period"
Environment="RUNNER_INITIAL_GRACE_PERIOD=$runner_initial_grace_period"
ExecStart=/usr/local/bin/check-runner-termination.sh
EOF

cat > /etc/systemd/system/runner-termination-check.timer << EOF
[Unit]
Description=Periodic GitHub runner termination check
Requires=runner-termination-check.service
[Timer]
OnBootSec=60s
OnUnitActiveSec=${runner_poll_interval}s
[Install]
WantedBy=timers.target
EOF

systemctl daemon-reload
systemctl enable runner-termination-check.timer
systemctl start runner-termination-check.timer

# Build metadata labels (using metadata fetched earlier)
METADATA_LABELS=",instance-id:$${INSTANCE_ID},instance-type:$${INSTANCE_TYPE}"
if [ -n "$github_workflow" ]; then
  WORKFLOW_LABEL=$$(echo "$github_workflow" | tr ' /' '-' | tr -cd '[:alnum:]-_')
  METADATA_LABELS="$${METADATA_LABELS},workflow:$${WORKFLOW_LABEL}"
fi
[ -n "$github_run_id" ] && METADATA_LABELS="$${METADATA_LABELS},run-id:$github_run_id"
[ -n "$github_run_number" ] && METADATA_LABELS="$${METADATA_LABELS},run-number:$github_run_number"

# Process each runner configuration
log "Setting up $$RUNNERS_PER_INSTANCE runner(s)"
python3 -c "
import json, sys, os, subprocess, traceback, base64

# Runner configurations passed from Python (base64 encoded to avoid shell escaping issues)
runner_configs_b64 = '$runner_configs_b64'
runner_configs_json = base64.b64decode(runner_configs_b64).decode()

try:
    configs = json.loads(runner_configs_json)
except Exception as e:
    print(f'ERROR: Failed to parse runner configs: {e}', file=sys.stderr)
    print(f'Input was: {runner_configs_json}', file=sys.stderr)
    traceback.print_exc()
    sys.exit(1)
homedir = '$$homedir'  # Use shell variable (already resolved from AUTO)
repo = '$repo'
instance_id = '$$INSTANCE_ID'
metadata_labels = '$$METADATA_LABELS'

print(f'Processing {len(configs)} runner configuration(s)', file=sys.stderr)
for config in configs:
    idx = config['runner_idx']
    token = config['token']
    labels = config['labels'] + metadata_labels

    print(f'Configuring runner {idx}...', file=sys.stderr)

    # Create runner directory
    runner_dir = f'{homedir}/runner-{idx}'
    os.makedirs(runner_dir, exist_ok=True)
    os.chdir(runner_dir)

    # Extract runner
    subprocess.run(['tar', '-xzf', '/tmp/runner.tar.gz'], check=True)

    # Save token for deregistration
    with open('.runner-token', 'w') as f:
        f.write(token)

    # Create env file
    with open('.env', 'w') as f:
        f.write(f'ACTIONS_RUNNER_HOOK_JOB_STARTED=/usr/local/bin/job-started-hook.sh\\n')
        f.write(f'ACTIONS_RUNNER_HOOK_JOB_COMPLETED=/usr/local/bin/job-completed-hook.sh\\n')
        f.write(f'RUNNER_HOME={runner_dir}\\n')
        f.write(f'RUNNER_INDEX={idx}\\n')
        f.write(f'RUNNER_GRACE_PERIOD=$runner_grace_period\\n')
        f.write(f'RUNNER_INITIAL_GRACE_PERIOD=$runner_initial_grace_period\\n')

    # Configure runner
    runner_name = f'ec2-{instance_id}-{idx}'
    cmd = ['./config.sh', '--url', f'https://github.com/{repo}', '--token', token,
           '--labels', labels, '--name', runner_name, '--disableupdate', '--unattended']
    result = subprocess.run(cmd, env={'RUNNER_ALLOW_RUNASROOT': '1'}, capture_output=True, text=True)

    # Check if registration succeeded (even if config.sh returns non-zero)
    if 'Runner successfully added' in result.stdout:
        print(f'Runner {idx} registered successfully', file=sys.stderr)
    elif result.returncode != 0:
        print(f'Failed to register runner {idx}: {result.stderr}', file=sys.stderr)
        sys.exit(1)

    # Inherit system environment and add RUNNER_ALLOW_RUNASROOT
    runner_env = os.environ.copy()
    runner_env['RUNNER_ALLOW_RUNASROOT'] = '1'
    # Start runner in background (use full path and handle errors)
    try:
        proc = subprocess.Popen([f'{runner_dir}/run.sh'],
                               env=runner_env,
                               cwd=runner_dir,
                               stdout=subprocess.DEVNULL,
                               stderr=subprocess.DEVNULL)
        print(f'Started runner {idx} in {runner_dir} (PID: {proc.pid})', file=sys.stderr)
    except Exception as e:
        print(f'Failed to start runner {idx}: {e}', file=sys.stderr)
        sys.exit(1)
"

if [ $$? -ne 0 ]; then
  terminate_instance "Failed to register runners"
fi

log "All runners registered and started"
touch /var/run/github-runner-registered

# Kill watchdog
if [ -f /var/run/github-runner-watchdog.pid ]; then
  WATCHDOG_PID=$$(cat /var/run/github-runner-watchdog.pid)
  kill $$WATCHDOG_PID 2>/dev/null || true
  rm -f /var/run/github-runner-watchdog.pid
fi

touch /var/run/github-runner-started
chmod o+x $$homedir
for RUNNER_DIR in $$homedir/runner-*; do
  [ -d "$$RUNNER_DIR/_diag" ] && chmod 755 "$$RUNNER_DIR/_diag"
done
