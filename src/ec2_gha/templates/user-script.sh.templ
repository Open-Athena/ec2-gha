#!/bin/bash
set -e

# Set up error handling and failsafe termination
INSTANCE_ID=$$(curl -s http://169.254.169.254/latest/meta-data/instance-id 2>/dev/null || echo "unknown")

terminate_instance() {
    local reason="$$1"
    echo "[$$(date '+%Y-%m-%d %H:%M:%S')] FATAL: $$reason" | tee -a /var/log/runner-setup.log
    echo "[$$(date '+%Y-%m-%d %H:%M:%S')] Terminating instance $$INSTANCE_ID due to setup failure" | tee -a /var/log/runner-setup.log

    # Try to remove runner if it was partially configured
    if [ -f "$$homedir/config.sh" ] && [ -n "$${RUNNER_TOKEN:-}" ]; then
        cd "$$homedir" && ./config.sh remove --token "$${RUNNER_TOKEN}" || true
    fi

    # Force termination
    shutdown -h now
    exit 1
}

# Trap errors and ensure termination on failure
trap 'terminate_instance "Setup script failed with error on line $$LINENO"' ERR

# Set up registration timeout failsafe (default 5 minutes if not specified)
REGISTRATION_TIMEOUT=$${runner_registration_timeout:-300}
(
    sleep $$REGISTRATION_TIMEOUT
    if [ ! -f /var/run/github-runner-registered ]; then
        terminate_instance "Runner failed to register within $$REGISTRATION_TIMEOUT seconds"
    fi
) &
REGISTRATION_WATCHDOG_PID=$$!
echo "[$$( date '+%Y-%m-%d %H:%M:%S')] Watchdog PID: $$REGISTRATION_WATCHDOG_PID"

$userdata

# Initialize homedir from template variable
homedir="$homedir"

# Determine home directory if not specified or set to AUTO
if [ -z "$$homedir" ] || [ "$$homedir" = "AUTO" ]; then
    # Try to find the default non-root user's home directory
    # Check for common cloud-init created users
    for user in ubuntu ec2-user centos admin debian fedora alpine arch; do
        if id "$$user" &>/dev/null; then
            homedir="/home/$$user"
            echo "[$$( date '+%Y-%m-%d %H:%M:%S')] Auto-detected: $$homedir"
            break
        fi
    done

    # Fallback if no standard user found
    if [ -z "$$homedir" ] || [ "$$homedir" = "AUTO" ]; then
        # Get the first non-root user's home directory that actually exists
        homedir=$$(getent passwd | awk -F: '$$3 >= 1000 && $$3 < 65534 && $$6 ~ /^\/home\// {print $$6}' | while read dir; do
            if [ -d "$$dir" ]; then
                echo "$$dir"
                break
            fi
        done)

        if [ -z "$$homedir" ]; then
            homedir="/home/ec2-user"  # Ultimate fallback
            echo "[$$( date '+%Y-%m-%d %H:%M:%S')] Using fallback: $$homedir"
        else
            # Use stat to get the actual owner of the directory
            owner=$$(stat -c "%U" "$$homedir" 2>/dev/null || stat -f "%Su" "$$homedir" 2>/dev/null)
            echo "[$$( date '+%Y-%m-%d %H:%M:%S')] Detected: $$homedir ($$owner)"
        fi
    fi
else
    echo "[$$( date '+%Y-%m-%d %H:%M:%S')] Using: $$homedir"
fi

# Set up maximum lifetime timeout - do this early to ensure cleanup
MAX_LIFETIME_MINUTES=$max_instance_lifetime
echo "[$$( date '+%Y-%m-%d %H:%M:%S')] Max lifetime: $${MAX_LIFETIME_MINUTES}m"
nohup bash -c "sleep $${MAX_LIFETIME_MINUTES}m && echo '[$$(date)] Maximum lifetime reached' && shutdown -h now" > /var/log/max-lifetime.log 2>&1 &

# Configure CloudWatch Logs if enabled
if [ "$cloudwatch_logs_group" != "" ]; then
    echo "[$$(date '+%Y-%m-%d %H:%M:%S')] Installing CloudWatch agent"
    # Use a subshell to prevent CloudWatch failures from stopping the entire script
    (

    # Wait for dpkg lock to be released (up to 2 minutes)
    echo "[$$(date '+%Y-%m-%d %H:%M:%S')] Waiting for dpkg lock to be released..."
    timeout=120
    while fuser /var/lib/dpkg/lock-frontend >/dev/null 2>&1 || fuser /var/lib/dpkg/lock >/dev/null 2>&1; do
        if [ $$timeout -le 0 ]; then
            echo "[$$(date '+%Y-%m-%d %H:%M:%S')] WARNING: dpkg lock timeout, proceeding anyway"
            break
        fi
        echo "[$$(date '+%Y-%m-%d %H:%M:%S')] dpkg is locked, waiting... ($$timeout seconds remaining)"
        sleep 5
        timeout=$$((timeout - 5))
    done

    # Download and install CloudWatch agent
    wget -q https://s3.amazonaws.com/amazoncloudwatch-agent/ubuntu/amd64/latest/amazon-cloudwatch-agent.deb
    dpkg -i -E ./amazon-cloudwatch-agent.deb
    rm amazon-cloudwatch-agent.deb

    # Configure CloudWatch agent
    cat > /opt/aws/amazon-cloudwatch-agent/etc/amazon-cloudwatch-agent.json << 'EOF'
{
  "agent": {
    "run_as_user": "cwagent"
  },
  "logs": {
    "logs_collected": {
      "files": {
        "collect_list": [
          {
            "file_path": "/var/log/runner-setup.log",
            "log_group_name": "$cloudwatch_logs_group",
            "log_stream_name": "{instance_id}/runner-setup",
            "timezone": "UTC"
          },
          {
            "file_path": "/tmp/job-started-hook.log",
            "log_group_name": "$cloudwatch_logs_group",
            "log_stream_name": "{instance_id}/job-started",
            "timezone": "UTC"
          },
          {
            "file_path": "/tmp/job-completed-hook.log",
            "log_group_name": "$cloudwatch_logs_group",
            "log_stream_name": "{instance_id}/job-completed",
            "timezone": "UTC"
          },
          {
            "file_path": "/tmp/termination-check.log",
            "log_group_name": "$cloudwatch_logs_group",
            "log_stream_name": "{instance_id}/termination",
            "timezone": "UTC"
          },
          {
            "file_path": "$$homedir/_diag/Runner_**.log",
            "log_group_name": "$cloudwatch_logs_group",
            "log_stream_name": "{instance_id}/runner-diag",
            "timezone": "UTC"
          },
          {
            "file_path": "$$homedir/_diag/Worker_**.log",
            "log_group_name": "$cloudwatch_logs_group",
            "log_stream_name": "{instance_id}/worker-diag",
            "timezone": "UTC"
          }
        ]
      }
    }
  }
}
EOF

    # Start CloudWatch agent
    /opt/aws/amazon-cloudwatch-agent/bin/amazon-cloudwatch-agent-ctl \
        -a fetch-config \
        -m ec2 \
        -c file:/opt/aws/amazon-cloudwatch-agent/etc/amazon-cloudwatch-agent.json \
        -s

    echo "[$$(date '+%Y-%m-%d %H:%M:%S')] CloudWatch agent started"
    ) || echo "[$$(date '+%Y-%m-%d %H:%M:%S')] WARNING: CloudWatch agent installation failed, continuing without it"
fi

# Configure SSH access if public key provided
if [ -n "$ssh_pubkey" ]; then
    echo "[$$(date '+%Y-%m-%d %H:%M:%S')] Configuring SSH access"

    # Determine the default user based on the home directory owner
    DEFAULT_USER=$$(stat -c "%U" "$$homedir" 2>/dev/null || echo "root")

    # Create .ssh directory if it doesn't exist
    mkdir -p "$$homedir/.ssh"
    chmod 700 "$$homedir/.ssh"

    # Add the public key to authorized_keys
    echo "$ssh_pubkey" >> "$$homedir/.ssh/authorized_keys"
    chmod 600 "$$homedir/.ssh/authorized_keys"

    # Set proper ownership
    if [ "$$DEFAULT_USER" != "root" ]; then
        chown -R "$$DEFAULT_USER:$$DEFAULT_USER" "$$homedir/.ssh"
    fi

    echo "[$$(date '+%Y-%m-%d %H:%M:%S')] SSH key added for user $$DEFAULT_USER"
fi

# Redirect runner setup logs to a file for CloudWatch
exec >> /var/log/runner-setup.log 2>&1
echo "[$$( date '+%Y-%m-%d %H:%M:%S')] Starting runner setup"

# Log instance metadata for later analysis
INSTANCE_TYPE=$$(curl -s http://169.254.169.254/latest/meta-data/instance-type 2>/dev/null || echo "unknown")
INSTANCE_ID=$$(curl -s http://169.254.169.254/latest/meta-data/instance-id 2>/dev/null || echo "unknown")
REGION=$$(curl -s http://169.254.169.254/latest/meta-data/placement/region 2>/dev/null || echo "unknown")
AZ=$$(curl -s http://169.254.169.254/latest/meta-data/placement/availability-zone 2>/dev/null || echo "unknown")

echo "[$$(date '+%Y-%m-%d %H:%M:%S')] Instance metadata:"
echo "  Instance type: $${INSTANCE_TYPE}"
echo "  Instance ID: $${INSTANCE_ID}"
echo "  Region: $${REGION}"
echo "  Availability zone: $${AZ}"

echo "[$$(date '+%Y-%m-%d %H:%M:%S')] Working directory: $$homedir"
cd "$$homedir"
echo "$script" > pre-runner-script.sh
echo "[$$(date '+%Y-%m-%d %H:%M:%S')] Running pre-runner script"
source pre-runner-script.sh
export RUNNER_ALLOW_RUNASROOT=1
# We will get the latest release from the GitHub API
echo "[$$(date '+%Y-%m-%d %H:%M:%S')] Downloading runner from: $runner_release"
curl -L $runner_release -o runner.tar.gz
echo "[$$(date '+%Y-%m-%d %H:%M:%S')] Extracting runner"
# `--no-overwrite-dir` is important, otherwise `$$homedir` ends up `chown`'d to `1001:docker`, and `sshd` will refuse connection attempts to `$$homedir`
tar --no-overwrite-dir -xzf runner.tar.gz
echo "[$$(date '+%Y-%m-%d %H:%M:%S')] Setting up job tracking scripts"
# Create minimal job tracking scripts inline
cat > /usr/local/bin/job-started-hook.sh << 'EOFS'
#!/bin/bash
exec >> /tmp/job-started-hook.log 2>&1
echo "[$$(date)] Job STARTED  : $${GITHUB_WORKFLOW}/$${GITHUB_JOB} (Run: $${GITHUB_RUN_ID}/$${GITHUB_RUN_NUMBER}, Attempt: $${GITHUB_RUN_ATTEMPT})"
echo "  Repository: $${GITHUB_REPOSITORY}"
echo "  Runner: $${RUNNER_NAME}"
JOB_TRACK_DIR="/var/run/github-runner-jobs"
mkdir -p "$${JOB_TRACK_DIR}"
echo "{\"job_id\":\"$${GITHUB_JOB}\",\"run_id\":\"$${GITHUB_RUN_ID}\",\"workflow\":\"$${GITHUB_WORKFLOW}\",\"status\":\"running\"}" > "$${JOB_TRACK_DIR}/$${GITHUB_RUN_ID}-$${GITHUB_JOB}.job"
# Update activity timestamp
touch /var/run/github-runner-last-activity
EOFS

cat > /usr/local/bin/job-completed-hook.sh << 'EOFC'
#!/bin/bash
exec >> /tmp/job-completed-hook.log 2>&1
echo "[$$(date)] Job COMPLETED: $${GITHUB_WORKFLOW}/$${GITHUB_JOB} (Run: $${GITHUB_RUN_ID}/$${GITHUB_RUN_NUMBER}, Attempt: $${GITHUB_RUN_ATTEMPT})"
echo "  Repository: $${GITHUB_REPOSITORY}"
echo "  Runner: $${RUNNER_NAME}"
JOB_TRACK_DIR="/var/run/github-runner-jobs"
if [ -f "$${JOB_TRACK_DIR}/$${GITHUB_RUN_ID}-$${GITHUB_JOB}.job" ]; then
    sed -i 's/"status":"running"/"status":"completed"/' "$${JOB_TRACK_DIR}/$${GITHUB_RUN_ID}-$${GITHUB_JOB}.job"
fi
# Count remaining running jobs
RUNNING_JOBS=$$(grep -l '"status":"running"' "$${JOB_TRACK_DIR}"/*.job 2>/dev/null | wc -l || echo 0)
echo "  Running jobs remaining: $${RUNNING_JOBS}"
# Update activity timestamp
touch /var/run/github-runner-last-activity
EOFC

cat > /usr/local/bin/check-runner-termination.sh << 'EOFT'
#!/bin/bash
exec >> /tmp/termination-check.log 2>&1
echo "[$$(date)] Checking termination conditions"

ACTIVITY_FILE="/var/run/github-runner-last-activity"
GRACE_PERIOD="$${RUNNER_GRACE_PERIOD:-60}"
INITIAL_GRACE_PERIOD="$${RUNNER_INITIAL_GRACE_PERIOD:-180}"
JOB_TRACK_DIR="/var/run/github-runner-jobs"

# Check if activity file exists
if [ ! -f "$${ACTIVITY_FILE}" ]; then
    echo "[$$(date)] WARNING: No activity file found, creating it now"
    touch "$${ACTIVITY_FILE}"
fi

# Get last activity time and current time
LAST_ACTIVITY=$$(stat -c %Y "$${ACTIVITY_FILE}" 2>/dev/null || echo 0)
NOW=$$(date +%s)
IDLE_TIME=$$((NOW - LAST_ACTIVITY))

# Check if any jobs have ever run
if ls "$${JOB_TRACK_DIR}"/*.job 2>/dev/null | grep -q .; then
    JOBS_HAVE_RUN=true
    CURRENT_GRACE_PERIOD="$${GRACE_PERIOD}"
else
    JOBS_HAVE_RUN=false
    CURRENT_GRACE_PERIOD="$${INITIAL_GRACE_PERIOD}"
fi

echo "[$$(date)] Last activity: $$(date -d @$${LAST_ACTIVITY} '+%Y-%m-%d %H:%M:%S')"
echo "[$$(date)] Current time: $$(date '+%Y-%m-%d %H:%M:%S')"
echo "[$$(date)] Idle time: $${IDLE_TIME} seconds (grace period: $${CURRENT_GRACE_PERIOD} seconds)"
echo "[$$(date)] Jobs have run: $${JOBS_HAVE_RUN}"

# Check for running jobs first
RUNNING_JOBS=$$(grep -l '"status":"running"' "$${JOB_TRACK_DIR}"/*.job 2>/dev/null | wc -l || echo 0)
echo "[$$(date)] Running jobs: $${RUNNING_JOBS}"

# Show status of each job for debugging
echo "[$$(date)] Current job files:"
for job_file in "$${JOB_TRACK_DIR}"/*.job; do
    if [ -f "$${job_file}" ]; then
        job_status=$$(grep -o '"status":"[^"]*"' "$${job_file}" || echo "unknown")
        echo "[$$(date)]   $$(basename "$${job_file}"): $${job_status}"
    fi
done || echo "[$$(date)]   No job files found"

# Never terminate if jobs are running
if [ "$${RUNNING_JOBS}" -gt 0 ]; then
    echo "[$$(date)] Jobs are still running, not checking idle time"
elif [ "$${IDLE_TIME}" -gt "$${CURRENT_GRACE_PERIOD}" ]; then
    echo "[$$(date)] No running jobs and no activity for $${IDLE_TIME} seconds, proceeding with termination"

    # Try to remove runner from GitHub first
    if [ -f "$$homedir/config.sh" ]; then
        echo "[$$(date)] Removing runner from GitHub"
        cd "$$homedir"
        # Stop the runner service
        RUNNER_PID=$$(pgrep -f "Runner.Listener" | head -1)
        if [ -n "$${RUNNER_PID}" ]; then
            echo "[$$(date)] Stopping runner PID $${RUNNER_PID}"
            kill -INT "$${RUNNER_PID}" 2>/dev/null || true
            # Wait for it to stop
            for i in {1..10}; do
                if ! kill -0 "$${RUNNER_PID}" 2>/dev/null; then
                    echo "[$$(date)] Runner stopped"
                    break
                fi
                sleep 1
            done
        fi

        # Remove runner from GitHub
        # We need RUNNER_ALLOW_RUNASROOT=1 to remove as root, just like when we configured it
        if RUNNER_ALLOW_RUNASROOT=1 ./config.sh remove --token $token; then
            echo "[$$(date)] Runner removed from GitHub successfully"
        else
            echo "[$$(date)] Failed to remove runner from GitHub"
        fi
    fi

    # Flush CloudWatch logs before shutdown
    echo "[$$(date)] Flushing CloudWatch logs"
    sync
    sleep 5

    sudo shutdown -h now "Runner terminating after idle timeout"
else
    echo "[$$(date)] Activity detected within $${CURRENT_GRACE_PERIOD} seconds, not terminating"
fi
EOFT

chmod +x /usr/local/bin/job-started-hook.sh /usr/local/bin/job-completed-hook.sh /usr/local/bin/check-runner-termination.sh

# Set up runner hooks
echo "ACTIONS_RUNNER_HOOK_JOB_STARTED=/usr/local/bin/job-started-hook.sh" > .env
echo "ACTIONS_RUNNER_HOOK_JOB_COMPLETED=/usr/local/bin/job-completed-hook.sh" >> .env
echo "RUNNER_HOME=$$homedir" >> .env
echo "RUNNER_GRACE_PERIOD=$runner_grace_period" >> .env
echo "RUNNER_INITIAL_GRACE_PERIOD=$runner_initial_grace_period" >> .env
echo "RUNNER_POLL_INTERVAL=$runner_poll_interval" >> .env

# Set up job tracking directory
mkdir -p /var/run/github-runner-jobs

# Create initial activity timestamp
touch /var/run/github-runner-last-activity

# Set up periodic termination check using systemd
cat > /etc/systemd/system/runner-termination-check.service << 'EOF'
[Unit]
Description=Check GitHub runner termination conditions
After=network.target

[Service]
Type=oneshot
ExecStart=/usr/local/bin/check-runner-termination.sh
EOF

cat > /etc/systemd/system/runner-termination-check.timer << EOF
[Unit]
Description=Periodic GitHub runner termination check
Requires=runner-termination-check.service

[Timer]
OnBootSec=60s
OnUnitActiveSec=${runner_poll_interval}s

[Install]
WantedBy=timers.target
EOF

# Enable and start the timer
systemctl daemon-reload
systemctl enable runner-termination-check.timer
systemctl start runner-termination-check.timer

# Get instance metadata for descriptive runner name
INSTANCE_ID=$$(wget -q -O - http://169.254.169.254/latest/meta-data/instance-id || echo "unknown")
INSTANCE_TYPE=$$(wget -q -O - http://169.254.169.254/latest/meta-data/instance-type || echo "unknown")

# Create runner name with just the instance ID for uniqueness
RUNNER_NAME="ec2-$${INSTANCE_ID}"

# Build additional labels with metadata for easier correlation
# These will be visible in the GitHub runner management UI
METADATA_LABELS=""
METADATA_LABELS="$${METADATA_LABELS},instance-id:$${INSTANCE_ID}"
METADATA_LABELS="$${METADATA_LABELS},instance-type:$${INSTANCE_TYPE}"

# Add GitHub workflow metadata passed from the action
if [ -n "$github_workflow" ]; then
    # Replace spaces and special chars in workflow name for label compatibility
    WORKFLOW_LABEL=$$(echo "$github_workflow" | tr ' /' '-' | tr -cd '[:alnum:]-_')
    METADATA_LABELS="$${METADATA_LABELS},workflow:$${WORKFLOW_LABEL}"
fi
if [ -n "$github_run_id" ]; then
    METADATA_LABELS="$${METADATA_LABELS},run-id:$github_run_id"
fi
if [ -n "$github_run_number" ]; then
    METADATA_LABELS="$${METADATA_LABELS},run-number:$github_run_number"
fi

# Combine provided labels (user + runner-xxx) with instance metadata labels
# The $labels variable already contains user labels and the critical runner-xxx label from Python
ALL_LABELS="$labels$${METADATA_LABELS}"

echo "[$$(date '+%Y-%m-%d %H:%M:%S')] Configuring runner for repo: $repo"
echo "[$$(date '+%Y-%m-%d %H:%M:%S')] Runner name: $${RUNNER_NAME}"
echo "[$$(date '+%Y-%m-%d %H:%M:%S')] Labels: $${ALL_LABELS}"
# Export token for error handler
export RUNNER_TOKEN="$token"
./config.sh --url https://github.com/$repo --token $token --labels "$${ALL_LABELS}" --name "$${RUNNER_NAME}" --disableupdate
echo "[$$(date '+%Y-%m-%d %H:%M:%S')] Runner registered successfully"

# Mark registration as complete and kill the watchdog
touch /var/run/github-runner-registered
if [ -n "$${REGISTRATION_WATCHDOG_PID:-}" ]; then
    kill $$REGISTRATION_WATCHDOG_PID 2>/dev/null || true
    echo "[$$(date '+%Y-%m-%d %H:%M:%S')] Killed registration watchdog (PID: $$REGISTRATION_WATCHDOG_PID)"
fi

echo "[$$(date '+%Y-%m-%d %H:%M:%S')] Starting runner"
# Create marker file for cleanup service
touch /var/run/github-runner-started
# Ensure CloudWatch agent can read diagnostic logs
# The cwagent user needs to traverse into $homedir to reach _diag
# Make $homedir world-executable (but not readable) so cwagent can traverse it
chmod o+x $$homedir
echo "[$$(date '+%Y-%m-%d %H:%M:%S')] Made $$homedir traversable for CloudWatch agent"
# Create _diag directory if it doesn't exist
mkdir -p $$homedir/_diag
# The _diag files are already world-readable by default, just ensure the directory is too
chmod 755 $$homedir/_diag
./run.sh
