#!/bin/bash
set -e

# Set up error handling and failsafe termination
INSTANCE_ID=$$(curl -s http://169.254.169.254/latest/meta-data/instance-id 2>/dev/null || echo "unknown")

terminate_instance() {
    local reason="$$1"
    echo "[$$(date '+%Y-%m-%d %H:%M:%S')] FATAL: $$reason" | tee -a /var/log/runner-setup.log
    echo "[$$(date '+%Y-%m-%d %H:%M:%S')] Terminating instance $$INSTANCE_ID due to setup failure" | tee -a /var/log/runner-setup.log

    # Try to remove runner if it was partially configured
    if [ -f "$$homedir/config.sh" ] && [ -n "$${RUNNER_TOKEN:-}" ]; then
        cd "$$homedir" && ./config.sh remove --token "$${RUNNER_TOKEN}" || true
    fi

    # Force termination
    shutdown -h now
    exit 1
}

# Trap errors and ensure termination on failure
trap 'terminate_instance "Setup script failed with error on line $$LINENO"' ERR

# Set up registration timeout failsafe (default 5 minutes if not specified)
REGISTRATION_TIMEOUT=$${runner_registration_timeout:-300}
(
    sleep $$REGISTRATION_TIMEOUT
    if [ ! -f /var/run/github-runner-registered ]; then
        terminate_instance "Runner failed to register within $$REGISTRATION_TIMEOUT seconds"
    fi
) &
REGISTRATION_WATCHDOG_PID=$$!
echo "[$$( date '+%Y-%m-%d %H:%M:%S')] Watchdog PID: $$REGISTRATION_WATCHDOG_PID"

$userdata

# Initialize homedir from template variable
homedir="$homedir"

# Determine home directory if not specified or set to AUTO
if [ -z "$$homedir" ] || [ "$$homedir" = "AUTO" ]; then
    # Try to find the default non-root user's home directory
    # Check for common cloud-init created users
    for user in ubuntu ec2-user centos admin debian fedora alpine arch; do
        if id "$$user" &>/dev/null; then
            homedir="/home/$$user"
            echo "[$$( date '+%Y-%m-%d %H:%M:%S')] Auto-detected: $$homedir"
            break
        fi
    done

    # Fallback if no standard user found
    if [ -z "$$homedir" ] || [ "$$homedir" = "AUTO" ]; then
        # Get the first non-root user's home directory that actually exists
        homedir=$$(getent passwd | awk -F: '$$3 >= 1000 && $$3 < 65534 && $$6 ~ /^\/home\// {print $$6}' | while read dir; do
            if [ -d "$$dir" ]; then
                echo "$$dir"
                break
            fi
        done)

        if [ -z "$$homedir" ]; then
            homedir="/home/ec2-user"  # Ultimate fallback
            echo "[$$( date '+%Y-%m-%d %H:%M:%S')] Using fallback: $$homedir"
        else
            # Use stat to get the actual owner of the directory
            owner=$$(stat -c "%U" "$$homedir" 2>/dev/null || stat -f "%Su" "$$homedir" 2>/dev/null)
            echo "[$$( date '+%Y-%m-%d %H:%M:%S')] Detected: $$homedir ($$owner)"
        fi
    fi
else
    echo "[$$( date '+%Y-%m-%d %H:%M:%S')] Using: $$homedir"
fi

# Set up maximum lifetime timeout - do this early to ensure cleanup
MAX_LIFETIME_MINUTES=$max_instance_lifetime
echo "[$$( date '+%Y-%m-%d %H:%M:%S')] Max lifetime: $${MAX_LIFETIME_MINUTES}m"
nohup bash -c "sleep $${MAX_LIFETIME_MINUTES}m && echo '[$$(date)] Maximum lifetime reached' && shutdown -h now" > /var/log/max-lifetime.log 2>&1 &

# Configure CloudWatch Logs if enabled
if [ "$cloudwatch_logs_group" != "" ]; then
    echo "[$$(date '+%Y-%m-%d %H:%M:%S')] Installing CloudWatch agent"
    # Use a subshell to prevent CloudWatch failures from stopping the entire script
    (

    # Wait for dpkg lock to be released (up to 2 minutes)
    echo "[$$(date '+%Y-%m-%d %H:%M:%S')] Waiting for dpkg lock to be released..."
    timeout=120
    while fuser /var/lib/dpkg/lock-frontend >/dev/null 2>&1 || fuser /var/lib/dpkg/lock >/dev/null 2>&1; do
        if [ $$timeout -le 0 ]; then
            echo "[$$(date '+%Y-%m-%d %H:%M:%S')] WARNING: dpkg lock timeout, proceeding anyway"
            break
        fi
        echo "[$$(date '+%Y-%m-%d %H:%M:%S')] dpkg is locked, waiting... ($$timeout seconds remaining)"
        sleep 5
        timeout=$$((timeout - 5))
    done

    # Download and install CloudWatch agent
    wget -q https://s3.amazonaws.com/amazoncloudwatch-agent/ubuntu/amd64/latest/amazon-cloudwatch-agent.deb
    dpkg -i -E ./amazon-cloudwatch-agent.deb
    rm amazon-cloudwatch-agent.deb

    # Configure CloudWatch agent
    cat > /opt/aws/amazon-cloudwatch-agent/etc/amazon-cloudwatch-agent.json << 'EOF'
{
  "agent": {
    "run_as_user": "cwagent"
  },
  "logs": {
    "logs_collected": {
      "files": {
        "collect_list": [
          {
            "file_path": "/var/log/runner-setup.log",
            "log_group_name": "$cloudwatch_logs_group",
            "log_stream_name": "{instance_id}/runner-setup",
            "timezone": "UTC"
          },
          {
            "file_path": "/tmp/job-started-hook.log",
            "log_group_name": "$cloudwatch_logs_group",
            "log_stream_name": "{instance_id}/job-started",
            "timezone": "UTC"
          },
          {
            "file_path": "/tmp/job-completed-hook.log",
            "log_group_name": "$cloudwatch_logs_group",
            "log_stream_name": "{instance_id}/job-completed",
            "timezone": "UTC"
          },
          {
            "file_path": "/tmp/termination-check.log",
            "log_group_name": "$cloudwatch_logs_group",
            "log_stream_name": "{instance_id}/termination",
            "timezone": "UTC"
          },
          {
            "file_path": "$$homedir/_diag/Runner_**.log",
            "log_group_name": "$cloudwatch_logs_group",
            "log_stream_name": "{instance_id}/runner-diag",
            "timezone": "UTC"
          },
          {
            "file_path": "$$homedir/_diag/Worker_**.log",
            "log_group_name": "$cloudwatch_logs_group",
            "log_stream_name": "{instance_id}/worker-diag",
            "timezone": "UTC"
          }
        ]
      }
    }
  }
}
EOF

    # Start CloudWatch agent
    /opt/aws/amazon-cloudwatch-agent/bin/amazon-cloudwatch-agent-ctl \
        -a fetch-config \
        -m ec2 \
        -c file:/opt/aws/amazon-cloudwatch-agent/etc/amazon-cloudwatch-agent.json \
        -s

    echo "[$$(date '+%Y-%m-%d %H:%M:%S')] CloudWatch agent started"
    ) || echo "[$$(date '+%Y-%m-%d %H:%M:%S')] WARNING: CloudWatch agent installation failed, continuing without it"
fi

# Configure SSH access if public key provided
if [ -n "$ssh_pubkey" ]; then
    echo "[$$(date '+%Y-%m-%d %H:%M:%S')] Configuring SSH access"

    # Determine the default user based on the home directory owner
    DEFAULT_USER=$$(stat -c "%U" "$$homedir" 2>/dev/null || echo "root")

    # Create .ssh directory if it doesn't exist
    mkdir -p "$$homedir/.ssh"
    chmod 700 "$$homedir/.ssh"

    # Add the public key to authorized_keys
    echo "$ssh_pubkey" >> "$$homedir/.ssh/authorized_keys"
    chmod 600 "$$homedir/.ssh/authorized_keys"

    # Set proper ownership
    if [ "$$DEFAULT_USER" != "root" ]; then
        chown -R "$$DEFAULT_USER:$$DEFAULT_USER" "$$homedir/.ssh"
    fi

    echo "[$$(date '+%Y-%m-%d %H:%M:%S')] SSH key added for user $$DEFAULT_USER"
fi

# Fetch instance metadata before redirecting output
INSTANCE_TYPE=$$(curl -s http://169.254.169.254/latest/meta-data/instance-type || echo "unknown")
INSTANCE_ID=$$(curl -s http://169.254.169.254/latest/meta-data/instance-id || echo "unknown")
REGION=$$(curl -s http://169.254.169.254/latest/meta-data/placement/region || echo "unknown")
AZ=$$(curl -s http://169.254.169.254/latest/meta-data/placement/availability-zone || echo "unknown")

# Redirect runner setup logs to a file for CloudWatch
exec >> /var/log/runner-setup.log 2>&1
echo "[$$( date '+%Y-%m-%d %H:%M:%S')] Starting runner setup"

echo "[$$(date '+%Y-%m-%d %H:%M:%S')] Instance metadata:"
echo "  Instance type: $${INSTANCE_TYPE}"
echo "  Instance ID: $${INSTANCE_ID}"
echo "  Region: $${REGION}"
echo "  Availability zone: $${AZ}"

echo "[$$(date '+%Y-%m-%d %H:%M:%S')] Working directory: $$homedir"
cd "$$homedir"
echo "$script" > pre-runner-script.sh
echo "[$$(date '+%Y-%m-%d %H:%M:%S')] Running pre-runner script"
source pre-runner-script.sh
export RUNNER_ALLOW_RUNASROOT=1
# Detect architecture and download appropriate runner
ARCH=$$(uname -m)
if [ "$$ARCH" = "aarch64" ] || [ "$$ARCH" = "arm64" ]; then
    # For ARM, replace x64 with arm64 in the URL
    RUNNER_URL=$$(echo "$runner_release" | sed 's/x64/arm64/g')
    echo "[$$(date '+%Y-%m-%d %H:%M:%S')] ARM detected, using: $$RUNNER_URL"
else
    RUNNER_URL="$runner_release"
    echo "[$$(date '+%Y-%m-%d %H:%M:%S')] x64 detected, using: $$RUNNER_URL"
fi
curl -L $$RUNNER_URL -o runner.tar.gz
echo "[$$(date '+%Y-%m-%d %H:%M:%S')] Extracting runner"
# `--no-overwrite-dir` is important, otherwise `$$homedir` ends up `chown`'d to `1001:docker`, and `sshd` will refuse connection attempts to `$$homedir`
tar --no-overwrite-dir -xzf runner.tar.gz
# Create job tracking scripts
cat > /usr/local/bin/job-started-hook.sh << 'EOFS'
#!/bin/bash
exec >> /tmp/job-started-hook.log 2>&1
echo "[$$(date)] Job started: $${GITHUB_JOB}"
mkdir -p /var/run/github-runner-jobs
echo '{"status":"running"}' > /var/run/github-runner-jobs/$${GITHUB_RUN_ID}-$${GITHUB_JOB}.job
touch /var/run/github-runner-last-activity
EOFS

cat > /usr/local/bin/job-completed-hook.sh << 'EOFC'
#!/bin/bash
exec >> /tmp/job-completed-hook.log 2>&1
echo "[$$(date)] Job completed: $${GITHUB_JOB}"
rm -f /var/run/github-runner-jobs/$${GITHUB_RUN_ID}-$${GITHUB_JOB}.job
touch /var/run/github-runner-last-activity
EOFC

cat > /usr/local/bin/check-runner-termination.sh << 'EOFT'
#!/bin/bash
exec >> /tmp/termination-check.log 2>&1
A="/var/run/github-runner-last-activity"
J="/var/run/github-runner-jobs"
[ ! -f "$$A" ] && touch "$$A"
L=$$(stat -c %Y "$$A" 2>/dev/null || echo 0)
I=$$(($$(date +%s)-L))
if ls $$J/*.job 2>/dev/null | grep -q .; then G=$${RUNNER_GRACE_PERIOD:-60}; else G=$${RUNNER_INITIAL_GRACE_PERIOD:-180}; fi
R=$$(grep -l '"status":"running"' $$J/*.job 2>/dev/null | wc -l || echo 0)
if [ $$R -eq 0 ] && [ $$I -gt $$G ]; then
    echo "[$$(date)] Terminating: idle $$I > grace $$G"
    [ -f "$$homedir/config.sh" ] && cd "$$homedir" && pkill -INT -f "Runner.Listener" 2>/dev/null || true
    sleep 2
    [ -f "$$homedir/config.sh" ] && RUNNER_ALLOW_RUNASROOT=1 ./config.sh remove --token $token || true
    shutdown -h now
fi
EOFT

chmod +x /usr/local/bin/job-started-hook.sh /usr/local/bin/job-completed-hook.sh /usr/local/bin/check-runner-termination.sh

# Set up runner hooks
echo "ACTIONS_RUNNER_HOOK_JOB_STARTED=/usr/local/bin/job-started-hook.sh" > .env
echo "ACTIONS_RUNNER_HOOK_JOB_COMPLETED=/usr/local/bin/job-completed-hook.sh" >> .env
echo "RUNNER_HOME=$$homedir" >> .env
echo "RUNNER_GRACE_PERIOD=$runner_grace_period" >> .env
echo "RUNNER_INITIAL_GRACE_PERIOD=$runner_initial_grace_period" >> .env
echo "RUNNER_POLL_INTERVAL=$runner_poll_interval" >> .env

# Set up job tracking directory
mkdir -p /var/run/github-runner-jobs

# Create initial activity timestamp
touch /var/run/github-runner-last-activity

# Set up periodic termination check using systemd
cat > /etc/systemd/system/runner-termination-check.service << 'EOF'
[Unit]
Description=Check GitHub runner termination conditions
After=network.target

[Service]
Type=oneshot
ExecStart=/usr/local/bin/check-runner-termination.sh
EOF

cat > /etc/systemd/system/runner-termination-check.timer << EOF
[Unit]
Description=Periodic GitHub runner termination check
Requires=runner-termination-check.service

[Timer]
OnBootSec=60s
OnUnitActiveSec=${runner_poll_interval}s

[Install]
WantedBy=timers.target
EOF

# Enable and start the timer
systemctl daemon-reload
systemctl enable runner-termination-check.timer
systemctl start runner-termination-check.timer

# Get instance metadata for descriptive runner name
INSTANCE_ID=$$(wget -q -O - http://169.254.169.254/latest/meta-data/instance-id || echo "unknown")
INSTANCE_TYPE=$$(wget -q -O - http://169.254.169.254/latest/meta-data/instance-type || echo "unknown")

# Create runner name with just the instance ID for uniqueness
RUNNER_NAME="ec2-$${INSTANCE_ID}"

# Build additional labels with metadata for easier correlation
# These will be visible in the GitHub runner management UI
METADATA_LABELS=""
METADATA_LABELS="$${METADATA_LABELS},instance-id:$${INSTANCE_ID}"
METADATA_LABELS="$${METADATA_LABELS},instance-type:$${INSTANCE_TYPE}"

# Add GitHub workflow metadata passed from the action
if [ -n "$github_workflow" ]; then
    # Replace spaces and special chars in workflow name for label compatibility
    WORKFLOW_LABEL=$$(echo "$github_workflow" | tr ' /' '-' | tr -cd '[:alnum:]-_')
    METADATA_LABELS="$${METADATA_LABELS},workflow:$${WORKFLOW_LABEL}"
fi
if [ -n "$github_run_id" ]; then
    METADATA_LABELS="$${METADATA_LABELS},run-id:$github_run_id"
fi
if [ -n "$github_run_number" ]; then
    METADATA_LABELS="$${METADATA_LABELS},run-number:$github_run_number"
fi

# Combine provided labels (user + runner-xxx) with instance metadata labels
# The $labels variable already contains user labels and the critical runner-xxx label from Python
ALL_LABELS="$labels$${METADATA_LABELS}"

echo "[$$(date '+%Y-%m-%d %H:%M:%S')] Configuring runner for repo: $repo"
echo "[$$(date '+%Y-%m-%d %H:%M:%S')] Runner name: $${RUNNER_NAME}"
echo "[$$(date '+%Y-%m-%d %H:%M:%S')] Labels: $${ALL_LABELS}"
# Export token for error handler
export RUNNER_TOKEN="$token"
./config.sh --url https://github.com/$repo --token $token --labels "$${ALL_LABELS}" --name "$${RUNNER_NAME}" --disableupdate
echo "[$$(date '+%Y-%m-%d %H:%M:%S')] Runner registered successfully"

# Mark registration as complete and kill the watchdog
touch /var/run/github-runner-registered
if [ -n "$${REGISTRATION_WATCHDOG_PID:-}" ]; then
    kill $$REGISTRATION_WATCHDOG_PID 2>/dev/null || true
    echo "[$$(date '+%Y-%m-%d %H:%M:%S')] Killed registration watchdog (PID: $$REGISTRATION_WATCHDOG_PID)"
fi

echo "[$$(date '+%Y-%m-%d %H:%M:%S')] Starting runner"
# Create marker file for cleanup service
touch /var/run/github-runner-started
# Ensure CloudWatch agent can read diagnostic logs
# The cwagent user needs to traverse into $homedir to reach _diag
# Make $homedir world-executable (but not readable) so cwagent can traverse it
chmod o+x $$homedir
echo "[$$(date '+%Y-%m-%d %H:%M:%S')] Made $$homedir traversable for CloudWatch agent"
# Create _diag directory if it doesn't exist
mkdir -p $$homedir/_diag
# The _diag files are already world-readable by default, just ensure the directory is too
chmod 755 $$homedir/_diag
./run.sh
