# serializer version: 1
# name: test_build_aws_params
  dict({
    'IamInstanceProfile': dict({
      'Name': 'test',
    }),
    'ImageId': 'ami-0772db4c976d21e9b',
    'InstanceInitiatedShutdownBehavior': 'terminate',
    'InstanceType': 't2.micro',
    'MaxCount': 1,
    'MinCount': 1,
    'SecurityGroupIds': list([
      'test',
    ]),
    'SubnetId': 'test',
    'TagSpecifications': list([
      dict({
        'ResourceType': 'instance',
        'Tags': list([
          dict({
            'Key': 'Name',
            'Value': 'test',
          }),
          dict({
            'Key': 'Owner',
            'Value': 'test',
          }),
          dict({
            'Key': 'Repository',
            'Value': 'Open-Athena/ec2-gha',
          }),
          dict({
            'Key': 'Workflow',
            'Value': 'CI',
          }),
          dict({
            'Key': 'URL',
            'Value': 'https://github.com/Open-Athena/ec2-gha/actions/runs/16725250800',
          }),
        ]),
      }),
    ]),
    'UserData': '''
      #!/bin/bash
      set -e
      
      exec 2> >(tee -a /var/log/runner-debug.log >&2)
      
      debug=""
      
      [ "" = "true" ] || [ "" = "True" ] || [ "" = "1" ] && set -x
      
      homedir="/home/ec2-user"
      if [ -z "$homedir" ] || [ "$homedir" = "AUTO" ]; then
        for user in ubuntu ec2-user centos admin debian fedora alpine arch; do
          if id "$user" &>/dev/null; then
            homedir="/home/$user"
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] Auto-detected homedir: $homedir" | tee -a /var/log/runner-setup.log
            break
          fi
        done
        
        if [ -z "$homedir" ] || [ "$homedir" = "AUTO" ]; then
          homedir=$(getent passwd | awk -F: '$3 >= 1000 && $3 < 65534 && $6 ~ /^\\/home\\// {print $6}' | while read dir; do
            if [ -d "$dir" ]; then
              echo "$dir"
              break
            fi
          done)
          if [ -z "$homedir" ]; then
            homedir="/home/ec2-user"  # Ultimate fallback
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] Using fallback homedir: $homedir" | tee -a /var/log/runner-setup.log
          else
            owner=$(stat -c "%U" "$homedir" 2>/dev/null || stat -f "%Su" "$homedir" 2>/dev/null)
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] Detected homedir: $homedir (owner: $owner)" | tee -a /var/log/runner-setup.log
          fi
        fi
      else
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] Using specified homedir: $homedir" | tee -a /var/log/runner-setup.log
      fi
      export homedir
      
      cat > /usr/local/bin/runner-common.sh << EOSF
      homedir="$homedir"
      debug="$debug"
      export homedir debug
      
      
      log() { echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a /var/log/runner-setup.log; }
      log_error() { log "ERROR: $1" >&2; }
      
      wait_for_dpkg_lock() {
        local timeout=120
        while fuser /var/lib/dpkg/lock-frontend >/dev/null 2>&1 || fuser /var/lib/dpkg/lock >/dev/null 2>&1; do
          if [ $timeout -le 0 ]; then
            log "WARNING: dpkg lock timeout, proceeding anyway"
            break
          fi
          log "dpkg is locked, waiting... ($timeout seconds remaining)"
          sleep 5
          timeout=$((timeout - 5))
        done
      }
      
      flush_cloudwatch_logs() {
        log "Stopping CloudWatch agent to flush logs"
        if systemctl is-active --quiet amazon-cloudwatch-agent; then
          systemctl stop amazon-cloudwatch-agent 2>/dev/null || /opt/aws/amazon-cloudwatch-agent/bin/amazon-cloudwatch-agent-ctl -a stop -m ec2 2>/dev/null || true
        fi
      }
      
      get_metadata() {
        local path="$1"
        local token=$(curl -X PUT -H "X-aws-ec2-metadata-token-ttl-seconds: 300" http://169.254.169.254/latest/api/token 2>/dev/null || true)
        if [ -n "$token" ]; then
          curl -s -H "X-aws-ec2-metadata-token: $token" "http://169.254.169.254/latest/meta-data/$path" 2>/dev/null || echo "unknown"
        else
          curl -s "http://169.254.169.254/latest/meta-data/$path" 2>/dev/null || echo "unknown"
        fi
        return 0  # Always return success to avoid set -e issues
      }
      
      deregister_all_runners() {
        for RUNNER_DIR in $homedir/runner-*; do
          if [ -d "$RUNNER_DIR" ] && [ -f "$RUNNER_DIR/config.sh" ]; then
            log "Deregistering runner in $RUNNER_DIR"
            cd "$RUNNER_DIR"
            pkill -INT -f "$RUNNER_DIR/run.sh" 2>/dev/null || true
            sleep 1
            if [ -f "$RUNNER_DIR/.runner-token" ]; then
              TOKEN=$(cat "$RUNNER_DIR/.runner-token")
              RUNNER_ALLOW_RUNASROOT=1 ./config.sh remove --token $TOKEN 2>&1
              log "Deregistration exit: $?"
            fi
          fi
        done
      }
      
      debug_sleep_and_shutdown() {
        if [ "$debug" = "true" ] || [ "$debug" = "True" ] || [ "$debug" = "1" ]; then
          log "Debug mode: Sleeping for 600 seconds before shutdown to allow debugging..."
          local ssh_user=$(basename "$homedir" 2>/dev/null || echo "ec2-user")
          local public_ip=$(curl -s http://169.254.169.254/latest/meta-data/public-ipv4)
          log "SSH into instance with: ssh ${ssh_user}@${public_ip}"
          log "Then check: /var/log/runner-setup.log and /var/log/runner-debug.log"
          sleep 600
          log "Debug period ended, shutting down"
        else
          log "Shutting down immediately (debug mode not enabled)"
        fi
        shutdown -h now
      }
      
      terminate_instance() {
        local reason="$1"
        local instance_id=$(get_metadata "instance-id")
      
        echo "========================================" | tee -a /var/log/runner-setup.log
        log "FATAL ERROR DETECTED"
        log "Reason: $reason"
        log "Instance: $instance_id"
        log "Script location: $(pwd)"
        log "User: $(whoami)"
        log "Debug trace available in: /var/log/runner-debug.log"
        echo "========================================" | tee -a /var/log/runner-setup.log
      
        if [ -f "$homedir/config.sh" ] && [ -n "${RUNNER_TOKEN:-}" ]; then
          cd "$homedir" && ./config.sh remove --token "${RUNNER_TOKEN}" || true
        fi
      
        flush_cloudwatch_logs
        debug_sleep_and_shutdown
        exit 1
      }
      
      configure_runner() {
        local idx=$1
        local token=$2
        local labels=$3
        local homedir=$4
        local repo=$5
        local instance_id=$6
        local runner_grace_period=$7
        local runner_initial_grace_period=$8
      
        log "Configuring runner $idx..."
      
        local runner_dir="$homedir/runner-$idx"
        mkdir -p "$runner_dir"
        cd "$runner_dir"
        tar -xzf /tmp/runner.tar.gz
      
        if [ -f ./bin/installdependencies.sh ]; then
          log "Installing runner dependencies..."
          sudo ./bin/installdependencies.sh >/dev/null 2>&1 || log "Warning: Some dependencies may have failed to install"
        fi
      
        echo "$token" > .runner-token
      
        cat > .env << EOF
      ACTIONS_RUNNER_HOOK_JOB_STARTED=/usr/local/bin/job-started-hook.sh
      ACTIONS_RUNNER_HOOK_JOB_COMPLETED=/usr/local/bin/job-completed-hook.sh
      RUNNER_HOME=$runner_dir
      RUNNER_INDEX=$idx
      RUNNER_GRACE_PERIOD=$runner_grace_period
      RUNNER_INITIAL_GRACE_PERIOD=$runner_initial_grace_period
      EOF
      
        local runner_name="ec2-$instance_id-$idx"
        RUNNER_ALLOW_RUNASROOT=1 ./config.sh --url "https://github.com/$repo" --token "$token" --labels "$labels" --name "$runner_name" --disableupdate --unattended 2>&1 | tee /tmp/runner-$idx-config.log
      
        if grep -q "Runner successfully added" /tmp/runner-$idx-config.log; then
          log "Runner $idx registered successfully"
        else
          log_error "Failed to register runner $idx"
          return 1
        fi
      
        RUNNER_ALLOW_RUNASROOT=1 nohup ./run.sh > /dev/null 2>&1 &
        local pid=$!
        log "Started runner $idx in $runner_dir (PID: $pid)"
      
        return 0
      }
      EOSF
      chmod +x /usr/local/bin/runner-common.sh
      source /usr/local/bin/runner-common.sh
      
      logger "EC2-GHA: Starting userdata script"
      trap 'logger "EC2-GHA: Script failed at line $LINENO with exit code $?"' ERR
      trap 'terminate_instance "Setup script failed with error on line $LINENO"' ERR
      
      REGISTRATION_TIMEOUT="300"
      if ! [[ "$REGISTRATION_TIMEOUT" =~ ^[0-9]+$ ]]; then
        logger "EC2-GHA: Invalid timeout '$REGISTRATION_TIMEOUT', using default 300"
        REGISTRATION_TIMEOUT=300
      fi
      logger "EC2-GHA: Registration timeout set to $REGISTRATION_TIMEOUT seconds"
      (
        log "Watchdog: Starting $REGISTRATION_TIMEOUT second timeout"
        sleep $REGISTRATION_TIMEOUT
        if [ ! -f /var/run/github-runner-registered ]; then
          log "Watchdog: Registration marker not found after timeout"
          terminate_instance "Runner failed to register within $REGISTRATION_TIMEOUT seconds"
        else
          log "Watchdog: Registration marker found, exiting normally"
        fi
      ) &
      REGISTRATION_WATCHDOG_PID=$!
      log "Watchdog PID: $REGISTRATION_WATCHDOG_PID"
      echo $REGISTRATION_WATCHDOG_PID > /var/run/github-runner-watchdog.pid
      
      
      
      exec >> /var/log/runner-setup.log 2>&1
      log "Starting runner setup"
      
      INSTANCE_TYPE=$(get_metadata "instance-type")
      INSTANCE_ID=$(get_metadata "instance-id")
      REGION=$(get_metadata "placement/region")
      AZ=$(get_metadata "placement/availability-zone")
      log "Instance metadata: Type=${INSTANCE_TYPE} ID=${INSTANCE_ID} Region=${REGION} AZ=${AZ}"
      
      MAX_LIFETIME_MINUTES=360
      log "Setting up maximum lifetime timeout: ${MAX_LIFETIME_MINUTES} minutes"
      nohup bash -c "sleep ${MAX_LIFETIME_MINUTES}m && echo '[$(date)] Maximum lifetime reached' && shutdown -h now" > /var/log/max-lifetime.log 2>&1 &
      
      if [ "" != "" ]; then
        log "Installing CloudWatch agent"
        (
          if command -v dpkg >/dev/null 2>&1; then
            log "Detected dpkg-based system"
            wait_for_dpkg_lock
            wget -q https://s3.amazonaws.com/amazoncloudwatch-agent/ubuntu/amd64/latest/amazon-cloudwatch-agent.deb
            dpkg -i -E ./amazon-cloudwatch-agent.deb
            rm amazon-cloudwatch-agent.deb
          elif command -v rpm >/dev/null 2>&1; then
            log "Detected rpm-based system"
            wget -q https://s3.amazonaws.com/amazoncloudwatch-agent/amazon_linux/amd64/latest/amazon-cloudwatch-agent.rpm
            rpm -U ./amazon-cloudwatch-agent.rpm
            rm amazon-cloudwatch-agent.rpm
          else
            log "WARNING: Unable to detect package manager, skipping CloudWatch agent installation"
          fi
          cat > /opt/aws/amazon-cloudwatch-agent/etc/amazon-cloudwatch-agent.json << EOF
      {"agent":{"run_as_user":"cwagent"},"logs":{"logs_collected":{"files":{"collect_list":[
      {"file_path":"/var/log/runner-setup.log","log_group_name":"","log_stream_name":"{instance_id}/runner-setup","timezone":"UTC"},
      {"file_path":"/var/log/runner-debug.log","log_group_name":"","log_stream_name":"{instance_id}/runner-debug","timezone":"UTC"},
      {"file_path":"/tmp/job-started-hook.log","log_group_name":"","log_stream_name":"{instance_id}/job-started","timezone":"UTC"},
      {"file_path":"/tmp/job-completed-hook.log","log_group_name":"","log_stream_name":"{instance_id}/job-completed","timezone":"UTC"},
      {"file_path":"/tmp/termination-check.log","log_group_name":"","log_stream_name":"{instance_id}/termination","timezone":"UTC"},
      {"file_path":"/tmp/runner-*-config.log","log_group_name":"","log_stream_name":"{instance_id}/runner-config","timezone":"UTC"},
      {"file_path":"/home/ec2-user/_diag/Runner_**.log","log_group_name":"","log_stream_name":"{instance_id}/runner-diag","timezone":"UTC"},
      {"file_path":"/home/ec2-user/_diag/Worker_**.log","log_group_name":"","log_stream_name":"{instance_id}/worker-diag","timezone":"UTC"}
      ]}}}}
      EOF
          /opt/aws/amazon-cloudwatch-agent/bin/amazon-cloudwatch-agent-ctl -a fetch-config -m ec2 -c file:/opt/aws/amazon-cloudwatch-agent/etc/amazon-cloudwatch-agent.json -s
          log "CloudWatch agent started"
        ) || log "WARNING: CloudWatch agent installation failed, continuing without it"
      fi
      
      if [ -n "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC test@host" ]; then
        log "Configuring SSH access"
        DEFAULT_USER=$(stat -c "%U" "$homedir" 2>/dev/null || echo "root")
        mkdir -p "$homedir/.ssh"
        chmod 700 "$homedir/.ssh"
        echo "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC test@host" >> "$homedir/.ssh/authorized_keys"
        chmod 600 "$homedir/.ssh/authorized_keys"
        if [ "$DEFAULT_USER" != "root" ]; then
          chown -R "$DEFAULT_USER:$DEFAULT_USER" "$homedir/.ssh"
        fi
        log "SSH key added for user $DEFAULT_USER"
      fi
      
      log "Working directory: $homedir"
      cd "$homedir"
      
      echo "echo 'Hello, World!'" > pre-runner-script.sh
      log "Running pre-runner script"
      source pre-runner-script.sh
      export RUNNER_ALLOW_RUNASROOT=1
      
      RUNNERS_PER_INSTANCE=1
      
      ARCH=$(uname -m)
      if [ "$ARCH" = "aarch64" ] || [ "$ARCH" = "arm64" ]; then
        RUNNER_URL=$(echo "test.tar.gz" | sed 's/x64/arm64/g')
        log "ARM detected, using: $RUNNER_URL"
      else
        RUNNER_URL="test.tar.gz"
        log "x64 detected, using: $RUNNER_URL"
      fi
      
      if command -v curl >/dev/null 2>&1; then
        curl -L $RUNNER_URL -o /tmp/runner.tar.gz
      elif command -v wget >/dev/null 2>&1; then
        wget -q $RUNNER_URL -O /tmp/runner.tar.gz
      else
        log_error "Neither curl nor wget found. Cannot download runner."
        terminate_instance "No download tool available"
      fi
      log "Downloaded runner binary"
      
      cat > /usr/local/bin/job-started-hook.sh << 'EOFS'
      #!/bin/bash
      exec >> /tmp/job-started-hook.log 2>&1
      V="/var/run/github-runner"
      RUNNER_IDX="${RUNNER_INDEX:-0}"
      echo "[$(date)] Runner-$RUNNER_IDX: Job started: ${GITHUB_JOB}"
      mkdir -p $V-jobs
      echo '{\"status\":\"running\",\"runner\":\"'$RUNNER_IDX'\"}' > $V-jobs/${GITHUB_RUN_ID}-${GITHUB_JOB}-$RUNNER_IDX.job
      touch $V-last-activity $V-has-run-job
      EOFS
      
      cat > /usr/local/bin/job-completed-hook.sh << 'EOFC'
      #!/bin/bash
      exec >> /tmp/job-completed-hook.log 2>&1
      V="/var/run/github-runner"
      RUNNER_IDX="${RUNNER_INDEX:-0}"
      echo "[$(date)] Runner-$RUNNER_IDX: Job completed: ${GITHUB_JOB}"
      rm -f $V-jobs/${GITHUB_RUN_ID}-${GITHUB_JOB}-$RUNNER_IDX.job
      touch $V-last-activity
      EOFC
      
      cat > /usr/local/bin/check-runner-termination.sh << EOFT
      #!/bin/bash
      exec >> /tmp/termination-check.log 2>&1
      source /usr/local/bin/runner-common.sh
      V="/var/run/github-runner"
      A="\\$V-last-activity"
      J="\\$V-jobs"
      H="\\$V-has-run-job"
      [ ! -f "\\$A" ] && touch "\\$A"
      L=\\$(stat -c %Y "\\$A" 2>/dev/null || echo 0)
      N=\\$(date +%s)
      I=\\$((N-L))
      [ -f "\\$H" ] && G=\\${RUNNER_GRACE_PERIOD:-60} || G=\\${RUNNER_INITIAL_GRACE_PERIOD:-180}
      R=\\$(grep -l '\"status\":\"running\"' \\$J/*.job 2>/dev/null | wc -l || echo 0)
      if [ \\$R -eq 0 ] && [ \\$I -gt \\$G ]; then
        log "TERMINATING: idle \\$I > grace \\$G"
        deregister_all_runners
        flush_cloudwatch_logs
        debug_sleep_and_shutdown
      else
        [ \\$R -gt 0 ] && log "\\$R job(s) running" || log "Idle \\$I/\\$G sec"
      fi
      EOFT
      
      chmod +x /usr/local/bin/job-started-hook.sh /usr/local/bin/job-completed-hook.sh /usr/local/bin/check-runner-termination.sh
      
      V="/var/run/github-runner"
      mkdir -p $V-jobs
      touch $V-last-activity
      
      cat > /etc/systemd/system/runner-termination-check.service << EOF
      [Unit]
      Description=Check GitHub runner termination conditions
      After=network.target
      [Service]
      Type=oneshot
      Environment="RUNNER_GRACE_PERIOD=61"
      Environment="RUNNER_INITIAL_GRACE_PERIOD=181"
      ExecStart=/usr/local/bin/check-runner-termination.sh
      EOF
      
      cat > /etc/systemd/system/runner-termination-check.timer << EOF
      [Unit]
      Description=Periodic GitHub runner termination check
      Requires=runner-termination-check.service
      [Timer]
      OnBootSec=60s
      OnUnitActiveSec=11s
      [Install]
      WantedBy=timers.target
      EOF
      
      systemctl daemon-reload
      systemctl enable runner-termination-check.timer
      systemctl start runner-termination-check.timer
      
      METADATA_LABELS=",instance-id:${INSTANCE_ID},instance-type:${INSTANCE_TYPE}"
      if [ -n "CI" ]; then
        WORKFLOW_LABEL=$(echo "CI" | tr ' /' '-' | tr -cd '[:alnum:]-_')
        METADATA_LABELS="${METADATA_LABELS},workflow:${WORKFLOW_LABEL}"
      fi
      [ -n "16725250800" ] && METADATA_LABELS="${METADATA_LABELS},run-id:16725250800"
      [ -n "1" ] && METADATA_LABELS="${METADATA_LABELS},run-number:1"
      
      log "Setting up $RUNNERS_PER_INSTANCE runner(s)"
      
      export -f configure_runner
      export -f log
      export -f log_error
      export -f get_metadata
      export -f flush_cloudwatch_logs
      export -f deregister_all_runners
      export -f debug_sleep_and_shutdown
      export -f wait_for_dpkg_lock
      
      IFS=' ' read -ra tokens <<< "test"
      IFS='|' read -ra labels <<< "label"
      
      num_runners=${#tokens[@]}
      log "Configuring $num_runners runner(s) in parallel"
      
      pids=()
      for i in ${!tokens[@]}; do
        token=${tokens[$i]}
        label=${labels[$i]:-}
        if [ -z "$token" ]; then
          log_error "No token for runner $i"
          continue
        fi
        (
          configure_runner $i "$token" "${label}$METADATA_LABELS" "$homedir" "omsf-eco-infra/awsinfratesting" "$INSTANCE_ID" "61" "181"
          echo $? > /tmp/runner-$i-status
        ) &
        pids+=($!)
        log "Started configuration for runner $i (PID: ${pids[-1]})"
      done
      
      log "Waiting for all runner configurations to complete..."
      failed=0
      for i in ${!pids[@]}; do
        wait ${pids[$i]}
        if [ -f /tmp/runner-$i-status ]; then
          status=$(cat /tmp/runner-$i-status)
          rm -f /tmp/runner-$i-status
          if [ "$status" != "0" ]; then
            log_error "Runner $i configuration failed"
            failed=1
          fi
        fi
      done
      
      if [ $failed -ne 0 ]; then
        terminate_instance "One or more runners failed to register"
      fi
      
      log "All runners registered and started"
      touch /var/run/github-runner-registered
      
      if [ -f /var/run/github-runner-watchdog.pid ]; then
        WATCHDOG_PID=$(cat /var/run/github-runner-watchdog.pid)
        kill $WATCHDOG_PID 2>/dev/null || true
        rm -f /var/run/github-runner-watchdog.pid
      fi
      
      touch /var/run/github-runner-started
      chmod o+x $homedir
      for RUNNER_DIR in $homedir/runner-*; do
        [ -d "$RUNNER_DIR/_diag" ] && chmod 755 "$RUNNER_DIR/_diag"
      done
    ''',
  })
# ---
# name: test_build_aws_params_with_idx
  dict({
    'IamInstanceProfile': dict({
      'Name': 'test',
    }),
    'ImageId': 'ami-0772db4c976d21e9b',
    'InstanceInitiatedShutdownBehavior': 'terminate',
    'InstanceType': 't2.micro',
    'MaxCount': 1,
    'MinCount': 1,
    'SecurityGroupIds': list([
      'test',
    ]),
    'SubnetId': 'test',
    'TagSpecifications': list([
      dict({
        'ResourceType': 'instance',
        'Tags': list([
          dict({
            'Key': 'Name',
            'Value': 'ec2-gha/test-0#42',
          }),
          dict({
            'Key': 'Repository',
            'Value': 'Open-Athena/ec2-gha',
          }),
          dict({
            'Key': 'Workflow',
            'Value': 'CI',
          }),
          dict({
            'Key': 'URL',
            'Value': 'https://github.com/Open-Athena/ec2-gha/actions/runs/16725250800',
          }),
        ]),
      }),
    ]),
    'UserData': '''
      #!/bin/bash
      set -e
      
      exec 2> >(tee -a /var/log/runner-debug.log >&2)
      
      debug=""
      
      [ "" = "true" ] || [ "" = "True" ] || [ "" = "1" ] && set -x
      
      homedir="/home/ec2-user"
      if [ -z "$homedir" ] || [ "$homedir" = "AUTO" ]; then
        for user in ubuntu ec2-user centos admin debian fedora alpine arch; do
          if id "$user" &>/dev/null; then
            homedir="/home/$user"
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] Auto-detected homedir: $homedir" | tee -a /var/log/runner-setup.log
            break
          fi
        done
        
        if [ -z "$homedir" ] || [ "$homedir" = "AUTO" ]; then
          homedir=$(getent passwd | awk -F: '$3 >= 1000 && $3 < 65534 && $6 ~ /^\\/home\\// {print $6}' | while read dir; do
            if [ -d "$dir" ]; then
              echo "$dir"
              break
            fi
          done)
          if [ -z "$homedir" ]; then
            homedir="/home/ec2-user"  # Ultimate fallback
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] Using fallback homedir: $homedir" | tee -a /var/log/runner-setup.log
          else
            owner=$(stat -c "%U" "$homedir" 2>/dev/null || stat -f "%Su" "$homedir" 2>/dev/null)
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] Detected homedir: $homedir (owner: $owner)" | tee -a /var/log/runner-setup.log
          fi
        fi
      else
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] Using specified homedir: $homedir" | tee -a /var/log/runner-setup.log
      fi
      export homedir
      
      cat > /usr/local/bin/runner-common.sh << EOSF
      homedir="$homedir"
      debug="$debug"
      export homedir debug
      
      
      log() { echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a /var/log/runner-setup.log; }
      log_error() { log "ERROR: $1" >&2; }
      
      wait_for_dpkg_lock() {
        local timeout=120
        while fuser /var/lib/dpkg/lock-frontend >/dev/null 2>&1 || fuser /var/lib/dpkg/lock >/dev/null 2>&1; do
          if [ $timeout -le 0 ]; then
            log "WARNING: dpkg lock timeout, proceeding anyway"
            break
          fi
          log "dpkg is locked, waiting... ($timeout seconds remaining)"
          sleep 5
          timeout=$((timeout - 5))
        done
      }
      
      flush_cloudwatch_logs() {
        log "Stopping CloudWatch agent to flush logs"
        if systemctl is-active --quiet amazon-cloudwatch-agent; then
          systemctl stop amazon-cloudwatch-agent 2>/dev/null || /opt/aws/amazon-cloudwatch-agent/bin/amazon-cloudwatch-agent-ctl -a stop -m ec2 2>/dev/null || true
        fi
      }
      
      get_metadata() {
        local path="$1"
        local token=$(curl -X PUT -H "X-aws-ec2-metadata-token-ttl-seconds: 300" http://169.254.169.254/latest/api/token 2>/dev/null || true)
        if [ -n "$token" ]; then
          curl -s -H "X-aws-ec2-metadata-token: $token" "http://169.254.169.254/latest/meta-data/$path" 2>/dev/null || echo "unknown"
        else
          curl -s "http://169.254.169.254/latest/meta-data/$path" 2>/dev/null || echo "unknown"
        fi
        return 0  # Always return success to avoid set -e issues
      }
      
      deregister_all_runners() {
        for RUNNER_DIR in $homedir/runner-*; do
          if [ -d "$RUNNER_DIR" ] && [ -f "$RUNNER_DIR/config.sh" ]; then
            log "Deregistering runner in $RUNNER_DIR"
            cd "$RUNNER_DIR"
            pkill -INT -f "$RUNNER_DIR/run.sh" 2>/dev/null || true
            sleep 1
            if [ -f "$RUNNER_DIR/.runner-token" ]; then
              TOKEN=$(cat "$RUNNER_DIR/.runner-token")
              RUNNER_ALLOW_RUNASROOT=1 ./config.sh remove --token $TOKEN 2>&1
              log "Deregistration exit: $?"
            fi
          fi
        done
      }
      
      debug_sleep_and_shutdown() {
        if [ "$debug" = "true" ] || [ "$debug" = "True" ] || [ "$debug" = "1" ]; then
          log "Debug mode: Sleeping for 600 seconds before shutdown to allow debugging..."
          local ssh_user=$(basename "$homedir" 2>/dev/null || echo "ec2-user")
          local public_ip=$(curl -s http://169.254.169.254/latest/meta-data/public-ipv4)
          log "SSH into instance with: ssh ${ssh_user}@${public_ip}"
          log "Then check: /var/log/runner-setup.log and /var/log/runner-debug.log"
          sleep 600
          log "Debug period ended, shutting down"
        else
          log "Shutting down immediately (debug mode not enabled)"
        fi
        shutdown -h now
      }
      
      terminate_instance() {
        local reason="$1"
        local instance_id=$(get_metadata "instance-id")
      
        echo "========================================" | tee -a /var/log/runner-setup.log
        log "FATAL ERROR DETECTED"
        log "Reason: $reason"
        log "Instance: $instance_id"
        log "Script location: $(pwd)"
        log "User: $(whoami)"
        log "Debug trace available in: /var/log/runner-debug.log"
        echo "========================================" | tee -a /var/log/runner-setup.log
      
        if [ -f "$homedir/config.sh" ] && [ -n "${RUNNER_TOKEN:-}" ]; then
          cd "$homedir" && ./config.sh remove --token "${RUNNER_TOKEN}" || true
        fi
      
        flush_cloudwatch_logs
        debug_sleep_and_shutdown
        exit 1
      }
      
      configure_runner() {
        local idx=$1
        local token=$2
        local labels=$3
        local homedir=$4
        local repo=$5
        local instance_id=$6
        local runner_grace_period=$7
        local runner_initial_grace_period=$8
      
        log "Configuring runner $idx..."
      
        local runner_dir="$homedir/runner-$idx"
        mkdir -p "$runner_dir"
        cd "$runner_dir"
        tar -xzf /tmp/runner.tar.gz
      
        if [ -f ./bin/installdependencies.sh ]; then
          log "Installing runner dependencies..."
          sudo ./bin/installdependencies.sh >/dev/null 2>&1 || log "Warning: Some dependencies may have failed to install"
        fi
      
        echo "$token" > .runner-token
      
        cat > .env << EOF
      ACTIONS_RUNNER_HOOK_JOB_STARTED=/usr/local/bin/job-started-hook.sh
      ACTIONS_RUNNER_HOOK_JOB_COMPLETED=/usr/local/bin/job-completed-hook.sh
      RUNNER_HOME=$runner_dir
      RUNNER_INDEX=$idx
      RUNNER_GRACE_PERIOD=$runner_grace_period
      RUNNER_INITIAL_GRACE_PERIOD=$runner_initial_grace_period
      EOF
      
        local runner_name="ec2-$instance_id-$idx"
        RUNNER_ALLOW_RUNASROOT=1 ./config.sh --url "https://github.com/$repo" --token "$token" --labels "$labels" --name "$runner_name" --disableupdate --unattended 2>&1 | tee /tmp/runner-$idx-config.log
      
        if grep -q "Runner successfully added" /tmp/runner-$idx-config.log; then
          log "Runner $idx registered successfully"
        else
          log_error "Failed to register runner $idx"
          return 1
        fi
      
        RUNNER_ALLOW_RUNASROOT=1 nohup ./run.sh > /dev/null 2>&1 &
        local pid=$!
        log "Started runner $idx in $runner_dir (PID: $pid)"
      
        return 0
      }
      EOSF
      chmod +x /usr/local/bin/runner-common.sh
      source /usr/local/bin/runner-common.sh
      
      logger "EC2-GHA: Starting userdata script"
      trap 'logger "EC2-GHA: Script failed at line $LINENO with exit code $?"' ERR
      trap 'terminate_instance "Setup script failed with error on line $LINENO"' ERR
      
      REGISTRATION_TIMEOUT="300"
      if ! [[ "$REGISTRATION_TIMEOUT" =~ ^[0-9]+$ ]]; then
        logger "EC2-GHA: Invalid timeout '$REGISTRATION_TIMEOUT', using default 300"
        REGISTRATION_TIMEOUT=300
      fi
      logger "EC2-GHA: Registration timeout set to $REGISTRATION_TIMEOUT seconds"
      (
        log "Watchdog: Starting $REGISTRATION_TIMEOUT second timeout"
        sleep $REGISTRATION_TIMEOUT
        if [ ! -f /var/run/github-runner-registered ]; then
          log "Watchdog: Registration marker not found after timeout"
          terminate_instance "Runner failed to register within $REGISTRATION_TIMEOUT seconds"
        else
          log "Watchdog: Registration marker found, exiting normally"
        fi
      ) &
      REGISTRATION_WATCHDOG_PID=$!
      log "Watchdog PID: $REGISTRATION_WATCHDOG_PID"
      echo $REGISTRATION_WATCHDOG_PID > /var/run/github-runner-watchdog.pid
      
      
      
      exec >> /var/log/runner-setup.log 2>&1
      log "Starting runner setup"
      
      INSTANCE_TYPE=$(get_metadata "instance-type")
      INSTANCE_ID=$(get_metadata "instance-id")
      REGION=$(get_metadata "placement/region")
      AZ=$(get_metadata "placement/availability-zone")
      log "Instance metadata: Type=${INSTANCE_TYPE} ID=${INSTANCE_ID} Region=${REGION} AZ=${AZ}"
      
      MAX_LIFETIME_MINUTES=360
      log "Setting up maximum lifetime timeout: ${MAX_LIFETIME_MINUTES} minutes"
      nohup bash -c "sleep ${MAX_LIFETIME_MINUTES}m && echo '[$(date)] Maximum lifetime reached' && shutdown -h now" > /var/log/max-lifetime.log 2>&1 &
      
      if [ "" != "" ]; then
        log "Installing CloudWatch agent"
        (
          if command -v dpkg >/dev/null 2>&1; then
            log "Detected dpkg-based system"
            wait_for_dpkg_lock
            wget -q https://s3.amazonaws.com/amazoncloudwatch-agent/ubuntu/amd64/latest/amazon-cloudwatch-agent.deb
            dpkg -i -E ./amazon-cloudwatch-agent.deb
            rm amazon-cloudwatch-agent.deb
          elif command -v rpm >/dev/null 2>&1; then
            log "Detected rpm-based system"
            wget -q https://s3.amazonaws.com/amazoncloudwatch-agent/amazon_linux/amd64/latest/amazon-cloudwatch-agent.rpm
            rpm -U ./amazon-cloudwatch-agent.rpm
            rm amazon-cloudwatch-agent.rpm
          else
            log "WARNING: Unable to detect package manager, skipping CloudWatch agent installation"
          fi
          cat > /opt/aws/amazon-cloudwatch-agent/etc/amazon-cloudwatch-agent.json << EOF
      {"agent":{"run_as_user":"cwagent"},"logs":{"logs_collected":{"files":{"collect_list":[
      {"file_path":"/var/log/runner-setup.log","log_group_name":"","log_stream_name":"{instance_id}/runner-setup","timezone":"UTC"},
      {"file_path":"/var/log/runner-debug.log","log_group_name":"","log_stream_name":"{instance_id}/runner-debug","timezone":"UTC"},
      {"file_path":"/tmp/job-started-hook.log","log_group_name":"","log_stream_name":"{instance_id}/job-started","timezone":"UTC"},
      {"file_path":"/tmp/job-completed-hook.log","log_group_name":"","log_stream_name":"{instance_id}/job-completed","timezone":"UTC"},
      {"file_path":"/tmp/termination-check.log","log_group_name":"","log_stream_name":"{instance_id}/termination","timezone":"UTC"},
      {"file_path":"/tmp/runner-*-config.log","log_group_name":"","log_stream_name":"{instance_id}/runner-config","timezone":"UTC"},
      {"file_path":"/home/ec2-user/_diag/Runner_**.log","log_group_name":"","log_stream_name":"{instance_id}/runner-diag","timezone":"UTC"},
      {"file_path":"/home/ec2-user/_diag/Worker_**.log","log_group_name":"","log_stream_name":"{instance_id}/worker-diag","timezone":"UTC"}
      ]}}}}
      EOF
          /opt/aws/amazon-cloudwatch-agent/bin/amazon-cloudwatch-agent-ctl -a fetch-config -m ec2 -c file:/opt/aws/amazon-cloudwatch-agent/etc/amazon-cloudwatch-agent.json -s
          log "CloudWatch agent started"
        ) || log "WARNING: CloudWatch agent installation failed, continuing without it"
      fi
      
      if [ -n "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC test@host" ]; then
        log "Configuring SSH access"
        DEFAULT_USER=$(stat -c "%U" "$homedir" 2>/dev/null || echo "root")
        mkdir -p "$homedir/.ssh"
        chmod 700 "$homedir/.ssh"
        echo "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC test@host" >> "$homedir/.ssh/authorized_keys"
        chmod 600 "$homedir/.ssh/authorized_keys"
        if [ "$DEFAULT_USER" != "root" ]; then
          chown -R "$DEFAULT_USER:$DEFAULT_USER" "$homedir/.ssh"
        fi
        log "SSH key added for user $DEFAULT_USER"
      fi
      
      log "Working directory: $homedir"
      cd "$homedir"
      
      echo "echo 'Hello, World!'" > pre-runner-script.sh
      log "Running pre-runner script"
      source pre-runner-script.sh
      export RUNNER_ALLOW_RUNASROOT=1
      
      RUNNERS_PER_INSTANCE=1
      
      ARCH=$(uname -m)
      if [ "$ARCH" = "aarch64" ] || [ "$ARCH" = "arm64" ]; then
        RUNNER_URL=$(echo "test.tar.gz" | sed 's/x64/arm64/g')
        log "ARM detected, using: $RUNNER_URL"
      else
        RUNNER_URL="test.tar.gz"
        log "x64 detected, using: $RUNNER_URL"
      fi
      
      if command -v curl >/dev/null 2>&1; then
        curl -L $RUNNER_URL -o /tmp/runner.tar.gz
      elif command -v wget >/dev/null 2>&1; then
        wget -q $RUNNER_URL -O /tmp/runner.tar.gz
      else
        log_error "Neither curl nor wget found. Cannot download runner."
        terminate_instance "No download tool available"
      fi
      log "Downloaded runner binary"
      
      cat > /usr/local/bin/job-started-hook.sh << 'EOFS'
      #!/bin/bash
      exec >> /tmp/job-started-hook.log 2>&1
      V="/var/run/github-runner"
      RUNNER_IDX="${RUNNER_INDEX:-0}"
      echo "[$(date)] Runner-$RUNNER_IDX: Job started: ${GITHUB_JOB}"
      mkdir -p $V-jobs
      echo '{\"status\":\"running\",\"runner\":\"'$RUNNER_IDX'\"}' > $V-jobs/${GITHUB_RUN_ID}-${GITHUB_JOB}-$RUNNER_IDX.job
      touch $V-last-activity $V-has-run-job
      EOFS
      
      cat > /usr/local/bin/job-completed-hook.sh << 'EOFC'
      #!/bin/bash
      exec >> /tmp/job-completed-hook.log 2>&1
      V="/var/run/github-runner"
      RUNNER_IDX="${RUNNER_INDEX:-0}"
      echo "[$(date)] Runner-$RUNNER_IDX: Job completed: ${GITHUB_JOB}"
      rm -f $V-jobs/${GITHUB_RUN_ID}-${GITHUB_JOB}-$RUNNER_IDX.job
      touch $V-last-activity
      EOFC
      
      cat > /usr/local/bin/check-runner-termination.sh << EOFT
      #!/bin/bash
      exec >> /tmp/termination-check.log 2>&1
      source /usr/local/bin/runner-common.sh
      V="/var/run/github-runner"
      A="\\$V-last-activity"
      J="\\$V-jobs"
      H="\\$V-has-run-job"
      [ ! -f "\\$A" ] && touch "\\$A"
      L=\\$(stat -c %Y "\\$A" 2>/dev/null || echo 0)
      N=\\$(date +%s)
      I=\\$((N-L))
      [ -f "\\$H" ] && G=\\${RUNNER_GRACE_PERIOD:-60} || G=\\${RUNNER_INITIAL_GRACE_PERIOD:-180}
      R=\\$(grep -l '\"status\":\"running\"' \\$J/*.job 2>/dev/null | wc -l || echo 0)
      if [ \\$R -eq 0 ] && [ \\$I -gt \\$G ]; then
        log "TERMINATING: idle \\$I > grace \\$G"
        deregister_all_runners
        flush_cloudwatch_logs
        debug_sleep_and_shutdown
      else
        [ \\$R -gt 0 ] && log "\\$R job(s) running" || log "Idle \\$I/\\$G sec"
      fi
      EOFT
      
      chmod +x /usr/local/bin/job-started-hook.sh /usr/local/bin/job-completed-hook.sh /usr/local/bin/check-runner-termination.sh
      
      V="/var/run/github-runner"
      mkdir -p $V-jobs
      touch $V-last-activity
      
      cat > /etc/systemd/system/runner-termination-check.service << EOF
      [Unit]
      Description=Check GitHub runner termination conditions
      After=network.target
      [Service]
      Type=oneshot
      Environment="RUNNER_GRACE_PERIOD=61"
      Environment="RUNNER_INITIAL_GRACE_PERIOD=181"
      ExecStart=/usr/local/bin/check-runner-termination.sh
      EOF
      
      cat > /etc/systemd/system/runner-termination-check.timer << EOF
      [Unit]
      Description=Periodic GitHub runner termination check
      Requires=runner-termination-check.service
      [Timer]
      OnBootSec=60s
      OnUnitActiveSec=11s
      [Install]
      WantedBy=timers.target
      EOF
      
      systemctl daemon-reload
      systemctl enable runner-termination-check.timer
      systemctl start runner-termination-check.timer
      
      METADATA_LABELS=",instance-id:${INSTANCE_ID},instance-type:${INSTANCE_TYPE}"
      if [ -n "CI" ]; then
        WORKFLOW_LABEL=$(echo "CI" | tr ' /' '-' | tr -cd '[:alnum:]-_')
        METADATA_LABELS="${METADATA_LABELS},workflow:${WORKFLOW_LABEL}"
      fi
      [ -n "16725250800" ] && METADATA_LABELS="${METADATA_LABELS},run-id:16725250800"
      [ -n "42" ] && METADATA_LABELS="${METADATA_LABELS},run-number:42"
      
      log "Setting up $RUNNERS_PER_INSTANCE runner(s)"
      
      export -f configure_runner
      export -f log
      export -f log_error
      export -f get_metadata
      export -f flush_cloudwatch_logs
      export -f deregister_all_runners
      export -f debug_sleep_and_shutdown
      export -f wait_for_dpkg_lock
      
      IFS=' ' read -ra tokens <<< "test"
      IFS='|' read -ra labels <<< "label"
      
      num_runners=${#tokens[@]}
      log "Configuring $num_runners runner(s) in parallel"
      
      pids=()
      for i in ${!tokens[@]}; do
        token=${tokens[$i]}
        label=${labels[$i]:-}
        if [ -z "$token" ]; then
          log_error "No token for runner $i"
          continue
        fi
        (
          configure_runner $i "$token" "${label}$METADATA_LABELS" "$homedir" "omsf-eco-infra/awsinfratesting" "$INSTANCE_ID" "61" "181"
          echo $? > /tmp/runner-$i-status
        ) &
        pids+=($!)
        log "Started configuration for runner $i (PID: ${pids[-1]})"
      done
      
      log "Waiting for all runner configurations to complete..."
      failed=0
      for i in ${!pids[@]}; do
        wait ${pids[$i]}
        if [ -f /tmp/runner-$i-status ]; then
          status=$(cat /tmp/runner-$i-status)
          rm -f /tmp/runner-$i-status
          if [ "$status" != "0" ]; then
            log_error "Runner $i configuration failed"
            failed=1
          fi
        fi
      done
      
      if [ $failed -ne 0 ]; then
        terminate_instance "One or more runners failed to register"
      fi
      
      log "All runners registered and started"
      touch /var/run/github-runner-registered
      
      if [ -f /var/run/github-runner-watchdog.pid ]; then
        WATCHDOG_PID=$(cat /var/run/github-runner-watchdog.pid)
        kill $WATCHDOG_PID 2>/dev/null || true
        rm -f /var/run/github-runner-watchdog.pid
      fi
      
      touch /var/run/github-runner-started
      chmod o+x $homedir
      for RUNNER_DIR in $homedir/runner-*; do
        [ -d "$RUNNER_DIR/_diag" ] && chmod 755 "$RUNNER_DIR/_diag"
      done
    ''',
  })
# ---
# name: test_build_user_data
  '''
  #!/bin/bash
  set -e
  
  exec 2> >(tee -a /var/log/runner-debug.log >&2)
  
  debug=""
  
  [ "" = "true" ] || [ "" = "True" ] || [ "" = "1" ] && set -x
  
  homedir="/home/ec2-user"
  if [ -z "$homedir" ] || [ "$homedir" = "AUTO" ]; then
    for user in ubuntu ec2-user centos admin debian fedora alpine arch; do
      if id "$user" &>/dev/null; then
        homedir="/home/$user"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] Auto-detected homedir: $homedir" | tee -a /var/log/runner-setup.log
        break
      fi
    done
    
    if [ -z "$homedir" ] || [ "$homedir" = "AUTO" ]; then
      homedir=$(getent passwd | awk -F: '$3 >= 1000 && $3 < 65534 && $6 ~ /^\\/home\\// {print $6}' | while read dir; do
        if [ -d "$dir" ]; then
          echo "$dir"
          break
        fi
      done)
      if [ -z "$homedir" ]; then
        homedir="/home/ec2-user"  # Ultimate fallback
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] Using fallback homedir: $homedir" | tee -a /var/log/runner-setup.log
      else
        owner=$(stat -c "%U" "$homedir" 2>/dev/null || stat -f "%Su" "$homedir" 2>/dev/null)
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] Detected homedir: $homedir (owner: $owner)" | tee -a /var/log/runner-setup.log
      fi
    fi
  else
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] Using specified homedir: $homedir" | tee -a /var/log/runner-setup.log
  fi
  export homedir
  
  cat > /usr/local/bin/runner-common.sh << EOSF
  homedir="$homedir"
  debug="$debug"
  export homedir debug
  
  
  log() { echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a /var/log/runner-setup.log; }
  log_error() { log "ERROR: $1" >&2; }
  
  wait_for_dpkg_lock() {
    local timeout=120
    while fuser /var/lib/dpkg/lock-frontend >/dev/null 2>&1 || fuser /var/lib/dpkg/lock >/dev/null 2>&1; do
      if [ $timeout -le 0 ]; then
        log "WARNING: dpkg lock timeout, proceeding anyway"
        break
      fi
      log "dpkg is locked, waiting... ($timeout seconds remaining)"
      sleep 5
      timeout=$((timeout - 5))
    done
  }
  
  flush_cloudwatch_logs() {
    log "Stopping CloudWatch agent to flush logs"
    if systemctl is-active --quiet amazon-cloudwatch-agent; then
      systemctl stop amazon-cloudwatch-agent 2>/dev/null || /opt/aws/amazon-cloudwatch-agent/bin/amazon-cloudwatch-agent-ctl -a stop -m ec2 2>/dev/null || true
    fi
  }
  
  get_metadata() {
    local path="$1"
    local token=$(curl -X PUT -H "X-aws-ec2-metadata-token-ttl-seconds: 300" http://169.254.169.254/latest/api/token 2>/dev/null || true)
    if [ -n "$token" ]; then
      curl -s -H "X-aws-ec2-metadata-token: $token" "http://169.254.169.254/latest/meta-data/$path" 2>/dev/null || echo "unknown"
    else
      curl -s "http://169.254.169.254/latest/meta-data/$path" 2>/dev/null || echo "unknown"
    fi
    return 0  # Always return success to avoid set -e issues
  }
  
  deregister_all_runners() {
    for RUNNER_DIR in $homedir/runner-*; do
      if [ -d "$RUNNER_DIR" ] && [ -f "$RUNNER_DIR/config.sh" ]; then
        log "Deregistering runner in $RUNNER_DIR"
        cd "$RUNNER_DIR"
        pkill -INT -f "$RUNNER_DIR/run.sh" 2>/dev/null || true
        sleep 1
        if [ -f "$RUNNER_DIR/.runner-token" ]; then
          TOKEN=$(cat "$RUNNER_DIR/.runner-token")
          RUNNER_ALLOW_RUNASROOT=1 ./config.sh remove --token $TOKEN 2>&1
          log "Deregistration exit: $?"
        fi
      fi
    done
  }
  
  debug_sleep_and_shutdown() {
    if [ "$debug" = "true" ] || [ "$debug" = "True" ] || [ "$debug" = "1" ]; then
      log "Debug mode: Sleeping for 600 seconds before shutdown to allow debugging..."
      local ssh_user=$(basename "$homedir" 2>/dev/null || echo "ec2-user")
      local public_ip=$(curl -s http://169.254.169.254/latest/meta-data/public-ipv4)
      log "SSH into instance with: ssh ${ssh_user}@${public_ip}"
      log "Then check: /var/log/runner-setup.log and /var/log/runner-debug.log"
      sleep 600
      log "Debug period ended, shutting down"
    else
      log "Shutting down immediately (debug mode not enabled)"
    fi
    shutdown -h now
  }
  
  terminate_instance() {
    local reason="$1"
    local instance_id=$(get_metadata "instance-id")
  
    echo "========================================" | tee -a /var/log/runner-setup.log
    log "FATAL ERROR DETECTED"
    log "Reason: $reason"
    log "Instance: $instance_id"
    log "Script location: $(pwd)"
    log "User: $(whoami)"
    log "Debug trace available in: /var/log/runner-debug.log"
    echo "========================================" | tee -a /var/log/runner-setup.log
  
    if [ -f "$homedir/config.sh" ] && [ -n "${RUNNER_TOKEN:-}" ]; then
      cd "$homedir" && ./config.sh remove --token "${RUNNER_TOKEN}" || true
    fi
  
    flush_cloudwatch_logs
    debug_sleep_and_shutdown
    exit 1
  }
  
  configure_runner() {
    local idx=$1
    local token=$2
    local labels=$3
    local homedir=$4
    local repo=$5
    local instance_id=$6
    local runner_grace_period=$7
    local runner_initial_grace_period=$8
  
    log "Configuring runner $idx..."
  
    local runner_dir="$homedir/runner-$idx"
    mkdir -p "$runner_dir"
    cd "$runner_dir"
    tar -xzf /tmp/runner.tar.gz
  
    if [ -f ./bin/installdependencies.sh ]; then
      log "Installing runner dependencies..."
      sudo ./bin/installdependencies.sh >/dev/null 2>&1 || log "Warning: Some dependencies may have failed to install"
    fi
  
    echo "$token" > .runner-token
  
    cat > .env << EOF
  ACTIONS_RUNNER_HOOK_JOB_STARTED=/usr/local/bin/job-started-hook.sh
  ACTIONS_RUNNER_HOOK_JOB_COMPLETED=/usr/local/bin/job-completed-hook.sh
  RUNNER_HOME=$runner_dir
  RUNNER_INDEX=$idx
  RUNNER_GRACE_PERIOD=$runner_grace_period
  RUNNER_INITIAL_GRACE_PERIOD=$runner_initial_grace_period
  EOF
  
    local runner_name="ec2-$instance_id-$idx"
    RUNNER_ALLOW_RUNASROOT=1 ./config.sh --url "https://github.com/$repo" --token "$token" --labels "$labels" --name "$runner_name" --disableupdate --unattended 2>&1 | tee /tmp/runner-$idx-config.log
  
    if grep -q "Runner successfully added" /tmp/runner-$idx-config.log; then
      log "Runner $idx registered successfully"
    else
      log_error "Failed to register runner $idx"
      return 1
    fi
  
    RUNNER_ALLOW_RUNASROOT=1 nohup ./run.sh > /dev/null 2>&1 &
    local pid=$!
    log "Started runner $idx in $runner_dir (PID: $pid)"
  
    return 0
  }
  EOSF
  chmod +x /usr/local/bin/runner-common.sh
  source /usr/local/bin/runner-common.sh
  
  logger "EC2-GHA: Starting userdata script"
  trap 'logger "EC2-GHA: Script failed at line $LINENO with exit code $?"' ERR
  trap 'terminate_instance "Setup script failed with error on line $LINENO"' ERR
  
  REGISTRATION_TIMEOUT="300"
  if ! [[ "$REGISTRATION_TIMEOUT" =~ ^[0-9]+$ ]]; then
    logger "EC2-GHA: Invalid timeout '$REGISTRATION_TIMEOUT', using default 300"
    REGISTRATION_TIMEOUT=300
  fi
  logger "EC2-GHA: Registration timeout set to $REGISTRATION_TIMEOUT seconds"
  (
    log "Watchdog: Starting $REGISTRATION_TIMEOUT second timeout"
    sleep $REGISTRATION_TIMEOUT
    if [ ! -f /var/run/github-runner-registered ]; then
      log "Watchdog: Registration marker not found after timeout"
      terminate_instance "Runner failed to register within $REGISTRATION_TIMEOUT seconds"
    else
      log "Watchdog: Registration marker found, exiting normally"
    fi
  ) &
  REGISTRATION_WATCHDOG_PID=$!
  log "Watchdog PID: $REGISTRATION_WATCHDOG_PID"
  echo $REGISTRATION_WATCHDOG_PID > /var/run/github-runner-watchdog.pid
  
  
  
  exec >> /var/log/runner-setup.log 2>&1
  log "Starting runner setup"
  
  INSTANCE_TYPE=$(get_metadata "instance-type")
  INSTANCE_ID=$(get_metadata "instance-id")
  REGION=$(get_metadata "placement/region")
  AZ=$(get_metadata "placement/availability-zone")
  log "Instance metadata: Type=${INSTANCE_TYPE} ID=${INSTANCE_ID} Region=${REGION} AZ=${AZ}"
  
  MAX_LIFETIME_MINUTES=360
  log "Setting up maximum lifetime timeout: ${MAX_LIFETIME_MINUTES} minutes"
  nohup bash -c "sleep ${MAX_LIFETIME_MINUTES}m && echo '[$(date)] Maximum lifetime reached' && shutdown -h now" > /var/log/max-lifetime.log 2>&1 &
  
  if [ "" != "" ]; then
    log "Installing CloudWatch agent"
    (
      if command -v dpkg >/dev/null 2>&1; then
        log "Detected dpkg-based system"
        wait_for_dpkg_lock
        wget -q https://s3.amazonaws.com/amazoncloudwatch-agent/ubuntu/amd64/latest/amazon-cloudwatch-agent.deb
        dpkg -i -E ./amazon-cloudwatch-agent.deb
        rm amazon-cloudwatch-agent.deb
      elif command -v rpm >/dev/null 2>&1; then
        log "Detected rpm-based system"
        wget -q https://s3.amazonaws.com/amazoncloudwatch-agent/amazon_linux/amd64/latest/amazon-cloudwatch-agent.rpm
        rpm -U ./amazon-cloudwatch-agent.rpm
        rm amazon-cloudwatch-agent.rpm
      else
        log "WARNING: Unable to detect package manager, skipping CloudWatch agent installation"
      fi
      cat > /opt/aws/amazon-cloudwatch-agent/etc/amazon-cloudwatch-agent.json << EOF
  {"agent":{"run_as_user":"cwagent"},"logs":{"logs_collected":{"files":{"collect_list":[
  {"file_path":"/var/log/runner-setup.log","log_group_name":"","log_stream_name":"{instance_id}/runner-setup","timezone":"UTC"},
  {"file_path":"/var/log/runner-debug.log","log_group_name":"","log_stream_name":"{instance_id}/runner-debug","timezone":"UTC"},
  {"file_path":"/tmp/job-started-hook.log","log_group_name":"","log_stream_name":"{instance_id}/job-started","timezone":"UTC"},
  {"file_path":"/tmp/job-completed-hook.log","log_group_name":"","log_stream_name":"{instance_id}/job-completed","timezone":"UTC"},
  {"file_path":"/tmp/termination-check.log","log_group_name":"","log_stream_name":"{instance_id}/termination","timezone":"UTC"},
  {"file_path":"/tmp/runner-*-config.log","log_group_name":"","log_stream_name":"{instance_id}/runner-config","timezone":"UTC"},
  {"file_path":"/home/ec2-user/_diag/Runner_**.log","log_group_name":"","log_stream_name":"{instance_id}/runner-diag","timezone":"UTC"},
  {"file_path":"/home/ec2-user/_diag/Worker_**.log","log_group_name":"","log_stream_name":"{instance_id}/worker-diag","timezone":"UTC"}
  ]}}}}
  EOF
      /opt/aws/amazon-cloudwatch-agent/bin/amazon-cloudwatch-agent-ctl -a fetch-config -m ec2 -c file:/opt/aws/amazon-cloudwatch-agent/etc/amazon-cloudwatch-agent.json -s
      log "CloudWatch agent started"
    ) || log "WARNING: CloudWatch agent installation failed, continuing without it"
  fi
  
  if [ -n "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC test@host" ]; then
    log "Configuring SSH access"
    DEFAULT_USER=$(stat -c "%U" "$homedir" 2>/dev/null || echo "root")
    mkdir -p "$homedir/.ssh"
    chmod 700 "$homedir/.ssh"
    echo "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC test@host" >> "$homedir/.ssh/authorized_keys"
    chmod 600 "$homedir/.ssh/authorized_keys"
    if [ "$DEFAULT_USER" != "root" ]; then
      chown -R "$DEFAULT_USER:$DEFAULT_USER" "$homedir/.ssh"
    fi
    log "SSH key added for user $DEFAULT_USER"
  fi
  
  log "Working directory: $homedir"
  cd "$homedir"
  
  echo "echo 'Hello, World!'" > pre-runner-script.sh
  log "Running pre-runner script"
  source pre-runner-script.sh
  export RUNNER_ALLOW_RUNASROOT=1
  
  RUNNERS_PER_INSTANCE=1
  
  ARCH=$(uname -m)
  if [ "$ARCH" = "aarch64" ] || [ "$ARCH" = "arm64" ]; then
    RUNNER_URL=$(echo "test.tar.gz" | sed 's/x64/arm64/g')
    log "ARM detected, using: $RUNNER_URL"
  else
    RUNNER_URL="test.tar.gz"
    log "x64 detected, using: $RUNNER_URL"
  fi
  
  if command -v curl >/dev/null 2>&1; then
    curl -L $RUNNER_URL -o /tmp/runner.tar.gz
  elif command -v wget >/dev/null 2>&1; then
    wget -q $RUNNER_URL -O /tmp/runner.tar.gz
  else
    log_error "Neither curl nor wget found. Cannot download runner."
    terminate_instance "No download tool available"
  fi
  log "Downloaded runner binary"
  
  cat > /usr/local/bin/job-started-hook.sh << 'EOFS'
  #!/bin/bash
  exec >> /tmp/job-started-hook.log 2>&1
  V="/var/run/github-runner"
  RUNNER_IDX="${RUNNER_INDEX:-0}"
  echo "[$(date)] Runner-$RUNNER_IDX: Job started: ${GITHUB_JOB}"
  mkdir -p $V-jobs
  echo '{\"status\":\"running\",\"runner\":\"'$RUNNER_IDX'\"}' > $V-jobs/${GITHUB_RUN_ID}-${GITHUB_JOB}-$RUNNER_IDX.job
  touch $V-last-activity $V-has-run-job
  EOFS
  
  cat > /usr/local/bin/job-completed-hook.sh << 'EOFC'
  #!/bin/bash
  exec >> /tmp/job-completed-hook.log 2>&1
  V="/var/run/github-runner"
  RUNNER_IDX="${RUNNER_INDEX:-0}"
  echo "[$(date)] Runner-$RUNNER_IDX: Job completed: ${GITHUB_JOB}"
  rm -f $V-jobs/${GITHUB_RUN_ID}-${GITHUB_JOB}-$RUNNER_IDX.job
  touch $V-last-activity
  EOFC
  
  cat > /usr/local/bin/check-runner-termination.sh << EOFT
  #!/bin/bash
  exec >> /tmp/termination-check.log 2>&1
  source /usr/local/bin/runner-common.sh
  V="/var/run/github-runner"
  A="\\$V-last-activity"
  J="\\$V-jobs"
  H="\\$V-has-run-job"
  [ ! -f "\\$A" ] && touch "\\$A"
  L=\\$(stat -c %Y "\\$A" 2>/dev/null || echo 0)
  N=\\$(date +%s)
  I=\\$((N-L))
  [ -f "\\$H" ] && G=\\${RUNNER_GRACE_PERIOD:-60} || G=\\${RUNNER_INITIAL_GRACE_PERIOD:-180}
  R=\\$(grep -l '\"status\":\"running\"' \\$J/*.job 2>/dev/null | wc -l || echo 0)
  if [ \\$R -eq 0 ] && [ \\$I -gt \\$G ]; then
    log "TERMINATING: idle \\$I > grace \\$G"
    deregister_all_runners
    flush_cloudwatch_logs
    debug_sleep_and_shutdown
  else
    [ \\$R -gt 0 ] && log "\\$R job(s) running" || log "Idle \\$I/\\$G sec"
  fi
  EOFT
  
  chmod +x /usr/local/bin/job-started-hook.sh /usr/local/bin/job-completed-hook.sh /usr/local/bin/check-runner-termination.sh
  
  V="/var/run/github-runner"
  mkdir -p $V-jobs
  touch $V-last-activity
  
  cat > /etc/systemd/system/runner-termination-check.service << EOF
  [Unit]
  Description=Check GitHub runner termination conditions
  After=network.target
  [Service]
  Type=oneshot
  Environment="RUNNER_GRACE_PERIOD=61"
  Environment="RUNNER_INITIAL_GRACE_PERIOD=181"
  ExecStart=/usr/local/bin/check-runner-termination.sh
  EOF
  
  cat > /etc/systemd/system/runner-termination-check.timer << EOF
  [Unit]
  Description=Periodic GitHub runner termination check
  Requires=runner-termination-check.service
  [Timer]
  OnBootSec=60s
  OnUnitActiveSec=11s
  [Install]
  WantedBy=timers.target
  EOF
  
  systemctl daemon-reload
  systemctl enable runner-termination-check.timer
  systemctl start runner-termination-check.timer
  
  METADATA_LABELS=",instance-id:${INSTANCE_ID},instance-type:${INSTANCE_TYPE}"
  if [ -n "CI" ]; then
    WORKFLOW_LABEL=$(echo "CI" | tr ' /' '-' | tr -cd '[:alnum:]-_')
    METADATA_LABELS="${METADATA_LABELS},workflow:${WORKFLOW_LABEL}"
  fi
  [ -n "16725250800" ] && METADATA_LABELS="${METADATA_LABELS},run-id:16725250800"
  [ -n "42" ] && METADATA_LABELS="${METADATA_LABELS},run-number:42"
  
  log "Setting up $RUNNERS_PER_INSTANCE runner(s)"
  
  export -f configure_runner
  export -f log
  export -f log_error
  export -f get_metadata
  export -f flush_cloudwatch_logs
  export -f deregister_all_runners
  export -f debug_sleep_and_shutdown
  export -f wait_for_dpkg_lock
  
  IFS=' ' read -ra tokens <<< "test"
  IFS='|' read -ra labels <<< "label"
  
  num_runners=${#tokens[@]}
  log "Configuring $num_runners runner(s) in parallel"
  
  pids=()
  for i in ${!tokens[@]}; do
    token=${tokens[$i]}
    label=${labels[$i]:-}
    if [ -z "$token" ]; then
      log_error "No token for runner $i"
      continue
    fi
    (
      configure_runner $i "$token" "${label}$METADATA_LABELS" "$homedir" "omsf-eco-infra/awsinfratesting" "$INSTANCE_ID" "61" "181"
      echo $? > /tmp/runner-$i-status
    ) &
    pids+=($!)
    log "Started configuration for runner $i (PID: ${pids[-1]})"
  done
  
  log "Waiting for all runner configurations to complete..."
  failed=0
  for i in ${!pids[@]}; do
    wait ${pids[$i]}
    if [ -f /tmp/runner-$i-status ]; then
      status=$(cat /tmp/runner-$i-status)
      rm -f /tmp/runner-$i-status
      if [ "$status" != "0" ]; then
        log_error "Runner $i configuration failed"
        failed=1
      fi
    fi
  done
  
  if [ $failed -ne 0 ]; then
    terminate_instance "One or more runners failed to register"
  fi
  
  log "All runners registered and started"
  touch /var/run/github-runner-registered
  
  if [ -f /var/run/github-runner-watchdog.pid ]; then
    WATCHDOG_PID=$(cat /var/run/github-runner-watchdog.pid)
    kill $WATCHDOG_PID 2>/dev/null || true
    rm -f /var/run/github-runner-watchdog.pid
  fi
  
  touch /var/run/github-runner-started
  chmod o+x $homedir
  for RUNNER_DIR in $homedir/runner-*; do
    [ -d "$RUNNER_DIR/_diag" ] && chmod 755 "$RUNNER_DIR/_diag"
  done
  '''
# ---
# name: test_build_user_data_with_cloudwatch
  '''
  #!/bin/bash
  set -e
  
  exec 2> >(tee -a /var/log/runner-debug.log >&2)
  
  debug=""
  
  [ "" = "true" ] || [ "" = "True" ] || [ "" = "1" ] && set -x
  
  homedir="/home/ec2-user"
  if [ -z "$homedir" ] || [ "$homedir" = "AUTO" ]; then
    for user in ubuntu ec2-user centos admin debian fedora alpine arch; do
      if id "$user" &>/dev/null; then
        homedir="/home/$user"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] Auto-detected homedir: $homedir" | tee -a /var/log/runner-setup.log
        break
      fi
    done
    
    if [ -z "$homedir" ] || [ "$homedir" = "AUTO" ]; then
      homedir=$(getent passwd | awk -F: '$3 >= 1000 && $3 < 65534 && $6 ~ /^\\/home\\// {print $6}' | while read dir; do
        if [ -d "$dir" ]; then
          echo "$dir"
          break
        fi
      done)
      if [ -z "$homedir" ]; then
        homedir="/home/ec2-user"  # Ultimate fallback
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] Using fallback homedir: $homedir" | tee -a /var/log/runner-setup.log
      else
        owner=$(stat -c "%U" "$homedir" 2>/dev/null || stat -f "%Su" "$homedir" 2>/dev/null)
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] Detected homedir: $homedir (owner: $owner)" | tee -a /var/log/runner-setup.log
      fi
    fi
  else
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] Using specified homedir: $homedir" | tee -a /var/log/runner-setup.log
  fi
  export homedir
  
  cat > /usr/local/bin/runner-common.sh << EOSF
  homedir="$homedir"
  debug="$debug"
  export homedir debug
  
  
  log() { echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a /var/log/runner-setup.log; }
  log_error() { log "ERROR: $1" >&2; }
  
  wait_for_dpkg_lock() {
    local timeout=120
    while fuser /var/lib/dpkg/lock-frontend >/dev/null 2>&1 || fuser /var/lib/dpkg/lock >/dev/null 2>&1; do
      if [ $timeout -le 0 ]; then
        log "WARNING: dpkg lock timeout, proceeding anyway"
        break
      fi
      log "dpkg is locked, waiting... ($timeout seconds remaining)"
      sleep 5
      timeout=$((timeout - 5))
    done
  }
  
  flush_cloudwatch_logs() {
    log "Stopping CloudWatch agent to flush logs"
    if systemctl is-active --quiet amazon-cloudwatch-agent; then
      systemctl stop amazon-cloudwatch-agent 2>/dev/null || /opt/aws/amazon-cloudwatch-agent/bin/amazon-cloudwatch-agent-ctl -a stop -m ec2 2>/dev/null || true
    fi
  }
  
  get_metadata() {
    local path="$1"
    local token=$(curl -X PUT -H "X-aws-ec2-metadata-token-ttl-seconds: 300" http://169.254.169.254/latest/api/token 2>/dev/null || true)
    if [ -n "$token" ]; then
      curl -s -H "X-aws-ec2-metadata-token: $token" "http://169.254.169.254/latest/meta-data/$path" 2>/dev/null || echo "unknown"
    else
      curl -s "http://169.254.169.254/latest/meta-data/$path" 2>/dev/null || echo "unknown"
    fi
    return 0  # Always return success to avoid set -e issues
  }
  
  deregister_all_runners() {
    for RUNNER_DIR in $homedir/runner-*; do
      if [ -d "$RUNNER_DIR" ] && [ -f "$RUNNER_DIR/config.sh" ]; then
        log "Deregistering runner in $RUNNER_DIR"
        cd "$RUNNER_DIR"
        pkill -INT -f "$RUNNER_DIR/run.sh" 2>/dev/null || true
        sleep 1
        if [ -f "$RUNNER_DIR/.runner-token" ]; then
          TOKEN=$(cat "$RUNNER_DIR/.runner-token")
          RUNNER_ALLOW_RUNASROOT=1 ./config.sh remove --token $TOKEN 2>&1
          log "Deregistration exit: $?"
        fi
      fi
    done
  }
  
  debug_sleep_and_shutdown() {
    if [ "$debug" = "true" ] || [ "$debug" = "True" ] || [ "$debug" = "1" ]; then
      log "Debug mode: Sleeping for 600 seconds before shutdown to allow debugging..."
      local ssh_user=$(basename "$homedir" 2>/dev/null || echo "ec2-user")
      local public_ip=$(curl -s http://169.254.169.254/latest/meta-data/public-ipv4)
      log "SSH into instance with: ssh ${ssh_user}@${public_ip}"
      log "Then check: /var/log/runner-setup.log and /var/log/runner-debug.log"
      sleep 600
      log "Debug period ended, shutting down"
    else
      log "Shutting down immediately (debug mode not enabled)"
    fi
    shutdown -h now
  }
  
  terminate_instance() {
    local reason="$1"
    local instance_id=$(get_metadata "instance-id")
  
    echo "========================================" | tee -a /var/log/runner-setup.log
    log "FATAL ERROR DETECTED"
    log "Reason: $reason"
    log "Instance: $instance_id"
    log "Script location: $(pwd)"
    log "User: $(whoami)"
    log "Debug trace available in: /var/log/runner-debug.log"
    echo "========================================" | tee -a /var/log/runner-setup.log
  
    if [ -f "$homedir/config.sh" ] && [ -n "${RUNNER_TOKEN:-}" ]; then
      cd "$homedir" && ./config.sh remove --token "${RUNNER_TOKEN}" || true
    fi
  
    flush_cloudwatch_logs
    debug_sleep_and_shutdown
    exit 1
  }
  
  configure_runner() {
    local idx=$1
    local token=$2
    local labels=$3
    local homedir=$4
    local repo=$5
    local instance_id=$6
    local runner_grace_period=$7
    local runner_initial_grace_period=$8
  
    log "Configuring runner $idx..."
  
    local runner_dir="$homedir/runner-$idx"
    mkdir -p "$runner_dir"
    cd "$runner_dir"
    tar -xzf /tmp/runner.tar.gz
  
    if [ -f ./bin/installdependencies.sh ]; then
      log "Installing runner dependencies..."
      sudo ./bin/installdependencies.sh >/dev/null 2>&1 || log "Warning: Some dependencies may have failed to install"
    fi
  
    echo "$token" > .runner-token
  
    cat > .env << EOF
  ACTIONS_RUNNER_HOOK_JOB_STARTED=/usr/local/bin/job-started-hook.sh
  ACTIONS_RUNNER_HOOK_JOB_COMPLETED=/usr/local/bin/job-completed-hook.sh
  RUNNER_HOME=$runner_dir
  RUNNER_INDEX=$idx
  RUNNER_GRACE_PERIOD=$runner_grace_period
  RUNNER_INITIAL_GRACE_PERIOD=$runner_initial_grace_period
  EOF
  
    local runner_name="ec2-$instance_id-$idx"
    RUNNER_ALLOW_RUNASROOT=1 ./config.sh --url "https://github.com/$repo" --token "$token" --labels "$labels" --name "$runner_name" --disableupdate --unattended 2>&1 | tee /tmp/runner-$idx-config.log
  
    if grep -q "Runner successfully added" /tmp/runner-$idx-config.log; then
      log "Runner $idx registered successfully"
    else
      log_error "Failed to register runner $idx"
      return 1
    fi
  
    RUNNER_ALLOW_RUNASROOT=1 nohup ./run.sh > /dev/null 2>&1 &
    local pid=$!
    log "Started runner $idx in $runner_dir (PID: $pid)"
  
    return 0
  }
  EOSF
  chmod +x /usr/local/bin/runner-common.sh
  source /usr/local/bin/runner-common.sh
  
  logger "EC2-GHA: Starting userdata script"
  trap 'logger "EC2-GHA: Script failed at line $LINENO with exit code $?"' ERR
  trap 'terminate_instance "Setup script failed with error on line $LINENO"' ERR
  
  REGISTRATION_TIMEOUT="300"
  if ! [[ "$REGISTRATION_TIMEOUT" =~ ^[0-9]+$ ]]; then
    logger "EC2-GHA: Invalid timeout '$REGISTRATION_TIMEOUT', using default 300"
    REGISTRATION_TIMEOUT=300
  fi
  logger "EC2-GHA: Registration timeout set to $REGISTRATION_TIMEOUT seconds"
  (
    log "Watchdog: Starting $REGISTRATION_TIMEOUT second timeout"
    sleep $REGISTRATION_TIMEOUT
    if [ ! -f /var/run/github-runner-registered ]; then
      log "Watchdog: Registration marker not found after timeout"
      terminate_instance "Runner failed to register within $REGISTRATION_TIMEOUT seconds"
    else
      log "Watchdog: Registration marker found, exiting normally"
    fi
  ) &
  REGISTRATION_WATCHDOG_PID=$!
  log "Watchdog PID: $REGISTRATION_WATCHDOG_PID"
  echo $REGISTRATION_WATCHDOG_PID > /var/run/github-runner-watchdog.pid
  
  
  
  exec >> /var/log/runner-setup.log 2>&1
  log "Starting runner setup"
  
  INSTANCE_TYPE=$(get_metadata "instance-type")
  INSTANCE_ID=$(get_metadata "instance-id")
  REGION=$(get_metadata "placement/region")
  AZ=$(get_metadata "placement/availability-zone")
  log "Instance metadata: Type=${INSTANCE_TYPE} ID=${INSTANCE_ID} Region=${REGION} AZ=${AZ}"
  
  MAX_LIFETIME_MINUTES=360
  log "Setting up maximum lifetime timeout: ${MAX_LIFETIME_MINUTES} minutes"
  nohup bash -c "sleep ${MAX_LIFETIME_MINUTES}m && echo '[$(date)] Maximum lifetime reached' && shutdown -h now" > /var/log/max-lifetime.log 2>&1 &
  
  if [ "/aws/ec2/github-runners" != "" ]; then
    log "Installing CloudWatch agent"
    (
      if command -v dpkg >/dev/null 2>&1; then
        log "Detected dpkg-based system"
        wait_for_dpkg_lock
        wget -q https://s3.amazonaws.com/amazoncloudwatch-agent/ubuntu/amd64/latest/amazon-cloudwatch-agent.deb
        dpkg -i -E ./amazon-cloudwatch-agent.deb
        rm amazon-cloudwatch-agent.deb
      elif command -v rpm >/dev/null 2>&1; then
        log "Detected rpm-based system"
        wget -q https://s3.amazonaws.com/amazoncloudwatch-agent/amazon_linux/amd64/latest/amazon-cloudwatch-agent.rpm
        rpm -U ./amazon-cloudwatch-agent.rpm
        rm amazon-cloudwatch-agent.rpm
      else
        log "WARNING: Unable to detect package manager, skipping CloudWatch agent installation"
      fi
      cat > /opt/aws/amazon-cloudwatch-agent/etc/amazon-cloudwatch-agent.json << EOF
  {"agent":{"run_as_user":"cwagent"},"logs":{"logs_collected":{"files":{"collect_list":[
  {"file_path":"/var/log/runner-setup.log","log_group_name":"/aws/ec2/github-runners","log_stream_name":"{instance_id}/runner-setup","timezone":"UTC"},
  {"file_path":"/var/log/runner-debug.log","log_group_name":"/aws/ec2/github-runners","log_stream_name":"{instance_id}/runner-debug","timezone":"UTC"},
  {"file_path":"/tmp/job-started-hook.log","log_group_name":"/aws/ec2/github-runners","log_stream_name":"{instance_id}/job-started","timezone":"UTC"},
  {"file_path":"/tmp/job-completed-hook.log","log_group_name":"/aws/ec2/github-runners","log_stream_name":"{instance_id}/job-completed","timezone":"UTC"},
  {"file_path":"/tmp/termination-check.log","log_group_name":"/aws/ec2/github-runners","log_stream_name":"{instance_id}/termination","timezone":"UTC"},
  {"file_path":"/tmp/runner-*-config.log","log_group_name":"/aws/ec2/github-runners","log_stream_name":"{instance_id}/runner-config","timezone":"UTC"},
  {"file_path":"/home/ec2-user/_diag/Runner_**.log","log_group_name":"/aws/ec2/github-runners","log_stream_name":"{instance_id}/runner-diag","timezone":"UTC"},
  {"file_path":"/home/ec2-user/_diag/Worker_**.log","log_group_name":"/aws/ec2/github-runners","log_stream_name":"{instance_id}/worker-diag","timezone":"UTC"}
  ]}}}}
  EOF
      /opt/aws/amazon-cloudwatch-agent/bin/amazon-cloudwatch-agent-ctl -a fetch-config -m ec2 -c file:/opt/aws/amazon-cloudwatch-agent/etc/amazon-cloudwatch-agent.json -s
      log "CloudWatch agent started"
    ) || log "WARNING: CloudWatch agent installation failed, continuing without it"
  fi
  
  if [ -n "" ]; then
    log "Configuring SSH access"
    DEFAULT_USER=$(stat -c "%U" "$homedir" 2>/dev/null || echo "root")
    mkdir -p "$homedir/.ssh"
    chmod 700 "$homedir/.ssh"
    echo "" >> "$homedir/.ssh/authorized_keys"
    chmod 600 "$homedir/.ssh/authorized_keys"
    if [ "$DEFAULT_USER" != "root" ]; then
      chown -R "$DEFAULT_USER:$DEFAULT_USER" "$homedir/.ssh"
    fi
    log "SSH key added for user $DEFAULT_USER"
  fi
  
  log "Working directory: $homedir"
  cd "$homedir"
  
  echo "echo 'Hello, World!'" > pre-runner-script.sh
  log "Running pre-runner script"
  source pre-runner-script.sh
  export RUNNER_ALLOW_RUNASROOT=1
  
  RUNNERS_PER_INSTANCE=1
  
  ARCH=$(uname -m)
  if [ "$ARCH" = "aarch64" ] || [ "$ARCH" = "arm64" ]; then
    RUNNER_URL=$(echo "test.tar.gz" | sed 's/x64/arm64/g')
    log "ARM detected, using: $RUNNER_URL"
  else
    RUNNER_URL="test.tar.gz"
    log "x64 detected, using: $RUNNER_URL"
  fi
  
  if command -v curl >/dev/null 2>&1; then
    curl -L $RUNNER_URL -o /tmp/runner.tar.gz
  elif command -v wget >/dev/null 2>&1; then
    wget -q $RUNNER_URL -O /tmp/runner.tar.gz
  else
    log_error "Neither curl nor wget found. Cannot download runner."
    terminate_instance "No download tool available"
  fi
  log "Downloaded runner binary"
  
  cat > /usr/local/bin/job-started-hook.sh << 'EOFS'
  #!/bin/bash
  exec >> /tmp/job-started-hook.log 2>&1
  V="/var/run/github-runner"
  RUNNER_IDX="${RUNNER_INDEX:-0}"
  echo "[$(date)] Runner-$RUNNER_IDX: Job started: ${GITHUB_JOB}"
  mkdir -p $V-jobs
  echo '{\"status\":\"running\",\"runner\":\"'$RUNNER_IDX'\"}' > $V-jobs/${GITHUB_RUN_ID}-${GITHUB_JOB}-$RUNNER_IDX.job
  touch $V-last-activity $V-has-run-job
  EOFS
  
  cat > /usr/local/bin/job-completed-hook.sh << 'EOFC'
  #!/bin/bash
  exec >> /tmp/job-completed-hook.log 2>&1
  V="/var/run/github-runner"
  RUNNER_IDX="${RUNNER_INDEX:-0}"
  echo "[$(date)] Runner-$RUNNER_IDX: Job completed: ${GITHUB_JOB}"
  rm -f $V-jobs/${GITHUB_RUN_ID}-${GITHUB_JOB}-$RUNNER_IDX.job
  touch $V-last-activity
  EOFC
  
  cat > /usr/local/bin/check-runner-termination.sh << EOFT
  #!/bin/bash
  exec >> /tmp/termination-check.log 2>&1
  source /usr/local/bin/runner-common.sh
  V="/var/run/github-runner"
  A="\\$V-last-activity"
  J="\\$V-jobs"
  H="\\$V-has-run-job"
  [ ! -f "\\$A" ] && touch "\\$A"
  L=\\$(stat -c %Y "\\$A" 2>/dev/null || echo 0)
  N=\\$(date +%s)
  I=\\$((N-L))
  [ -f "\\$H" ] && G=\\${RUNNER_GRACE_PERIOD:-60} || G=\\${RUNNER_INITIAL_GRACE_PERIOD:-180}
  R=\\$(grep -l '\"status\":\"running\"' \\$J/*.job 2>/dev/null | wc -l || echo 0)
  if [ \\$R -eq 0 ] && [ \\$I -gt \\$G ]; then
    log "TERMINATING: idle \\$I > grace \\$G"
    deregister_all_runners
    flush_cloudwatch_logs
    debug_sleep_and_shutdown
  else
    [ \\$R -gt 0 ] && log "\\$R job(s) running" || log "Idle \\$I/\\$G sec"
  fi
  EOFT
  
  chmod +x /usr/local/bin/job-started-hook.sh /usr/local/bin/job-completed-hook.sh /usr/local/bin/check-runner-termination.sh
  
  V="/var/run/github-runner"
  mkdir -p $V-jobs
  touch $V-last-activity
  
  cat > /etc/systemd/system/runner-termination-check.service << EOF
  [Unit]
  Description=Check GitHub runner termination conditions
  After=network.target
  [Service]
  Type=oneshot
  Environment="RUNNER_GRACE_PERIOD=61"
  Environment="RUNNER_INITIAL_GRACE_PERIOD=181"
  ExecStart=/usr/local/bin/check-runner-termination.sh
  EOF
  
  cat > /etc/systemd/system/runner-termination-check.timer << EOF
  [Unit]
  Description=Periodic GitHub runner termination check
  Requires=runner-termination-check.service
  [Timer]
  OnBootSec=60s
  OnUnitActiveSec=11s
  [Install]
  WantedBy=timers.target
  EOF
  
  systemctl daemon-reload
  systemctl enable runner-termination-check.timer
  systemctl start runner-termination-check.timer
  
  METADATA_LABELS=",instance-id:${INSTANCE_ID},instance-type:${INSTANCE_TYPE}"
  if [ -n "CI" ]; then
    WORKFLOW_LABEL=$(echo "CI" | tr ' /' '-' | tr -cd '[:alnum:]-_')
    METADATA_LABELS="${METADATA_LABELS},workflow:${WORKFLOW_LABEL}"
  fi
  [ -n "16725250800" ] && METADATA_LABELS="${METADATA_LABELS},run-id:16725250800"
  [ -n "42" ] && METADATA_LABELS="${METADATA_LABELS},run-number:42"
  
  log "Setting up $RUNNERS_PER_INSTANCE runner(s)"
  
  export -f configure_runner
  export -f log
  export -f log_error
  export -f get_metadata
  export -f flush_cloudwatch_logs
  export -f deregister_all_runners
  export -f debug_sleep_and_shutdown
  export -f wait_for_dpkg_lock
  
  IFS=' ' read -ra tokens <<< "test"
  IFS='|' read -ra labels <<< "label"
  
  num_runners=${#tokens[@]}
  log "Configuring $num_runners runner(s) in parallel"
  
  pids=()
  for i in ${!tokens[@]}; do
    token=${tokens[$i]}
    label=${labels[$i]:-}
    if [ -z "$token" ]; then
      log_error "No token for runner $i"
      continue
    fi
    (
      configure_runner $i "$token" "${label}$METADATA_LABELS" "$homedir" "omsf-eco-infra/awsinfratesting" "$INSTANCE_ID" "61" "181"
      echo $? > /tmp/runner-$i-status
    ) &
    pids+=($!)
    log "Started configuration for runner $i (PID: ${pids[-1]})"
  done
  
  log "Waiting for all runner configurations to complete..."
  failed=0
  for i in ${!pids[@]}; do
    wait ${pids[$i]}
    if [ -f /tmp/runner-$i-status ]; then
      status=$(cat /tmp/runner-$i-status)
      rm -f /tmp/runner-$i-status
      if [ "$status" != "0" ]; then
        log_error "Runner $i configuration failed"
        failed=1
      fi
    fi
  done
  
  if [ $failed -ne 0 ]; then
    terminate_instance "One or more runners failed to register"
  fi
  
  log "All runners registered and started"
  touch /var/run/github-runner-registered
  
  if [ -f /var/run/github-runner-watchdog.pid ]; then
    WATCHDOG_PID=$(cat /var/run/github-runner-watchdog.pid)
    kill $WATCHDOG_PID 2>/dev/null || true
    rm -f /var/run/github-runner-watchdog.pid
  fi
  
  touch /var/run/github-runner-started
  chmod o+x $homedir
  for RUNNER_DIR in $homedir/runner-*; do
    [ -d "$RUNNER_DIR/_diag" ] && chmod 755 "$RUNNER_DIR/_diag"
  done
  '''
# ---
